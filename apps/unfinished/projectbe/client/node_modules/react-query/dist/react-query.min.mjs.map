{"version":3,"file":"react-query.min.mjs","sources":["../src/utils.js","../src/config.js","../src/queryCache.js","../src/setFocusHandler.js","../src/useIsFetching.js","../src/useMutation.js","../src/useBaseQuery.js","../src/useQuery.js","../src/usePaginatedQuery.js","../src/useInfiniteQuery.js"],"sourcesContent":["import React from 'react'\n\n//\n\nexport const statusIdle = 'idle'\nexport const statusLoading = 'loading'\nexport const statusError = 'error'\nexport const statusSuccess = 'success'\n\nlet _uid = 0\nexport const uid = () => _uid++\nexport const cancelledError = {}\nexport let globalStateListeners = []\nexport const isServer = typeof window === 'undefined'\nexport const noop = () => {}\nexport const identity = d => d\nexport let Console = console || { error: noop, warn: noop, log: noop }\n\nexport function useUid() {\n  const ref = React.useRef(null)\n\n  if (ref.current === null) {\n    ref.current = uid()\n  }\n\n  return ref.current\n}\n\nexport function setConsole(c) {\n  Console = c\n}\n\nexport function useGetLatest(obj) {\n  const ref = React.useRef()\n  ref.current = obj\n\n  return React.useCallback(() => ref.current, [])\n}\n\nexport function functionalUpdate(updater, old) {\n  return typeof updater === 'function' ? updater(old) : updater\n}\n\nexport function stableStringifyReplacer(_, value) {\n  return isObject(value)\n    ? Object.assign(\n        {},\n        ...Object.keys(value)\n          .sort()\n          .map(key => ({\n            [key]: value[key],\n          }))\n      )\n    : value\n}\n\nexport function stableStringify(obj) {\n  return JSON.stringify(obj, stableStringifyReplacer)\n}\n\nexport function isObject(a) {\n  return a && typeof a === 'object' && !Array.isArray(a)\n}\n\nexport function deepIncludes(a, b) {\n  if (a === b) {\n    return true\n  }\n\n  if (typeof a !== typeof b) {\n    return false\n  }\n\n  if (typeof a === 'object') {\n    return !Object.keys(b).some(key => !deepIncludes(a[key], b[key]))\n  }\n\n  return false\n}\n\nexport function isDocumentVisible() {\n  return (\n    typeof document === 'undefined' ||\n    document.visibilityState === undefined ||\n    document.visibilityState === 'visible' ||\n    document.visibilityState === 'prerender'\n  )\n}\n\nexport function isOnline() {\n  return navigator.onLine === undefined || navigator.onLine\n}\n\nexport function getQueryArgs(args) {\n  if (isObject(args[0])) {\n    if (\n      args[0].hasOwnProperty('queryKey') &&\n      args[0].hasOwnProperty('queryFn')\n    ) {\n      const { queryKey, queryFn, config = {} } = args[0]\n      return [queryKey, queryFn, config, ...args.slice(1)]\n    } else {\n      throw new Error('queryKey and queryFn keys are required.')\n    }\n  }\n\n  const [queryKey, queryFn, config = {}, ...rest] = args\n\n  return [queryKey, queryFn, config, ...rest]\n}\n\nexport function useMountedCallback(callback) {\n  const mounted = React.useRef(false)\n\n  React[isServer ? 'useEffect' : 'useLayoutEffect'](() => {\n    mounted.current = true\n    return () => (mounted.current = false)\n  }, [])\n\n  return React.useCallback(\n    (...args) => (mounted.current ? callback(...args) : void 0),\n    [callback]\n  )\n}\n\nexport function handleSuspense(queryInfo) {\n  if (\n    queryInfo.query.config.suspense ||\n    queryInfo.query.config.useErrorBoundary\n  ) {\n    if (\n      queryInfo.query.state.status === statusError &&\n      queryInfo.query.state.throwInErrorBoundary\n    ) {\n      throw queryInfo.error\n    }\n\n    if (queryInfo.query.config.suspense && queryInfo.status !== statusSuccess) {\n      queryInfo.query.wasSuspended = true\n      throw queryInfo.query.fetch()\n    }\n  }\n}\n\n// This deep-equal is directly based on https://github.com/epoberezkin/fast-deep-equal.\n// The parts for comparing any non-JSON-supported values has been removed\nexport function deepEqual(a, b) {\n  if (a === b) return true\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    var length, i, keys\n    if (Array.isArray(a)) {\n      length = a.length\n      // eslint-disable-next-line eqeqeq\n      if (length != b.length) return false\n      for (i = length; i-- !== 0; ) if (!deepEqual(a[i], b[i])) return false\n      return true\n    }\n\n    if (a.valueOf !== Object.prototype.valueOf)\n      return a.valueOf() === b.valueOf()\n\n    keys = Object.keys(a)\n    length = keys.length\n    if (length !== Object.keys(b).length) return false\n\n    for (i = length; i-- !== 0; )\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false\n\n    for (i = length; i-- !== 0; ) {\n      var key = keys[i]\n\n      if (!deepEqual(a[key], b[key])) return false\n    }\n\n    return true\n  }\n\n  // true if both NaN, false otherwise\n  // eslint-disable-next-line no-self-compare\n  return a !== a && b !== b\n}\n","import React from 'react'\nimport { noop, stableStringify, identity, deepEqual } from './utils'\n\nexport const configContext = React.createContext()\n\nconst DEFAULTS = {\n  shared: {\n    suspense: false,\n    queryKeySerializerFn: defaultQueryKeySerializerFn,\n  },\n  queries: {\n    enabled: true,\n    retry: 3,\n    retryDelay: attemptIndex => Math.min(1000 * 2 ** attemptIndex, 30000),\n    staleTime: 0,\n    cacheTime: 5 * 60 * 1000,\n    refetchOnWindowFocus: true,\n    refetchInterval: false,\n    queryFnParamsFilter: identity,\n    refetchOnMount: true,\n    isDataEqual: deepEqual,\n    onError: noop,\n    onSuccess: noop,\n    onSettled: noop,\n    useErrorBoundary: false,\n  },\n  mutations: {\n    throwOnError: false,\n    onMutate: noop,\n    onError: noop,\n    onSuccess: noop,\n    onSettled: noop,\n    useErrorBoundary: false,\n  },\n}\n\nexport const defaultConfigRef = {\n  current: DEFAULTS,\n}\n\nexport function useConfigContext() {\n  return React.useContext(configContext) || defaultConfigRef.current\n}\n\nexport function ReactQueryConfigProvider({ config, children }) {\n  let configContextValue = useConfigContext()\n\n  const newConfig = React.useMemo(() => {\n    const { shared = {}, queries = {}, mutations = {} } = config\n    const {\n      shared: contextShared = {},\n      queries: contextQueries = {},\n      mutations: contextMutations = {},\n    } = configContextValue\n    return {\n      shared: {\n        ...contextShared,\n        ...shared,\n      },\n      queries: {\n        ...contextQueries,\n        ...queries,\n      },\n      mutations: {\n        ...contextMutations,\n        ...mutations,\n      },\n    }\n  }, [config, configContextValue])\n\n  React.useEffect(() => {\n    // restore previous config on unmount\n    return () => {\n      defaultConfigRef.current = { ...(configContextValue || DEFAULTS) }\n    }\n  }, [configContextValue])\n\n  if (!configContextValue) {\n    defaultConfigRef.current = newConfig\n  }\n\n  return (\n    <configContext.Provider value={newConfig}>\n      {children}\n    </configContext.Provider>\n  )\n}\n\nfunction invalidQueryKey() {\n  throw new Error('A valid query key is required!')\n}\n\nexport function defaultQueryKeySerializerFn(queryKey) {\n  if (!queryKey) {\n    invalidQueryKey()\n  }\n\n  if (!Array.isArray(queryKey)) {\n    queryKey = [queryKey]\n  }\n\n  if (queryKey.some(d => typeof d === 'function')) {\n    invalidQueryKey()\n  }\n\n  const queryHash = stableStringify(queryKey)\n  queryKey = JSON.parse(queryHash)\n\n  if (!queryHash) {\n    invalidQueryKey()\n  }\n\n  return [queryHash, queryKey]\n}\n","import React from 'react'\nimport {\n  isServer,\n  functionalUpdate,\n  cancelledError,\n  isDocumentVisible,\n  statusLoading,\n  statusSuccess,\n  statusError,\n  getQueryArgs,\n  deepIncludes,\n  noop,\n  uid,\n  statusIdle,\n  Console,\n} from './utils'\nimport { defaultConfigRef } from './config'\n\nexport const queryCache = makeQueryCache()\n\nexport const queryCacheContext = React.createContext(queryCache)\n\nexport const queryCaches = [queryCache]\n\nexport const useQueryCache = () => React.useContext(queryCacheContext)\n\nexport function ReactQueryCacheProvider({ queryCache, children }) {\n  const resolvedQueryCache = React.useMemo(\n    () => queryCache || makeQueryCache(),\n    [queryCache]\n  )\n\n  React.useEffect(() => {\n    queryCaches.push(resolvedQueryCache)\n\n    return () => {\n      // remove the cache from the active list\n      const i = queryCaches.indexOf(resolvedQueryCache)\n      if (i > -1) {\n        queryCaches.splice(i, 1)\n      }\n      // if the resolvedQueryCache was created by us, we need to tear it down\n      if (queryCache == null) {\n        resolvedQueryCache.clear()\n      }\n    }\n  }, [resolvedQueryCache, queryCache])\n\n  return (\n    <queryCacheContext.Provider value={resolvedQueryCache}>\n      {children}\n    </queryCacheContext.Provider>\n  )\n}\n\nconst actionInit = 'Init'\nconst actionFailed = 'Failed'\nconst actionMarkStale = 'MarkStale'\nconst actionMarkGC = 'MarkGC'\nconst actionFetch = 'Fetch'\nconst actionSuccess = 'Success'\nconst actionError = 'Error'\nconst actionSetState = 'SetState'\n\nexport function makeQueryCache({ frozen = isServer, defaultConfig } = {}) {\n  // A frozen cache does not add new queries to the cache\n  const globalListeners = []\n\n  const configRef = defaultConfig\n    ? { current: defaultConfig }\n    : defaultConfigRef\n\n  const queryCache = {\n    queries: {},\n    isFetching: 0,\n  }\n\n  const notifyGlobalListeners = () => {\n    queryCache.isFetching = Object.values(queryCache.queries).reduce(\n      (acc, query) => (query.state.isFetching ? acc + 1 : acc),\n      0\n    )\n\n    globalListeners.forEach(d => d(queryCache))\n  }\n\n  queryCache.subscribe = cb => {\n    globalListeners.push(cb)\n    return () => {\n      globalListeners.splice(globalListeners.indexOf(cb), 1)\n    }\n  }\n\n  queryCache.clear = ({ notify = true } = {}) => {\n    Object.values(queryCache.queries).forEach(query => query.clear())\n    queryCache.queries = {}\n    if (notify) {\n      notifyGlobalListeners()\n    }\n  }\n\n  queryCache.getQueries = (predicate, { exact } = {}) => {\n    if (predicate === true) {\n      return Object.values(queryCache.queries)\n    }\n\n    if (typeof predicate !== 'function') {\n      const [\n        queryHash,\n        queryKey,\n      ] = configRef.current.shared.queryKeySerializerFn(predicate)\n\n      predicate = d =>\n        exact ? d.queryHash === queryHash : deepIncludes(d.queryKey, queryKey)\n    }\n\n    return Object.values(queryCache.queries).filter(predicate)\n  }\n\n  queryCache.getQuery = queryKey =>\n    queryCache.getQueries(queryKey, { exact: true })[0]\n\n  queryCache.getQueryData = queryKey =>\n    queryCache.getQuery(queryKey)?.state.data\n\n  queryCache.removeQueries = (...args) => {\n    queryCache.getQueries(...args).forEach(query => query.clear())\n  }\n\n  queryCache.cancelQueries = (...args) => {\n    queryCache.getQueries(...args).forEach(query => query.cancel())\n  }\n\n  queryCache.invalidateQueries = async (\n    predicate,\n    { refetchActive = true, exact, throwOnError } = {}\n  ) => {\n    try {\n      return await Promise.all(\n        queryCache.getQueries(predicate, { exact }).map(query => {\n          if (refetchActive && query.instances.length) {\n            return query.fetch()\n          }\n\n          return query.invalidate()\n        })\n      )\n    } catch (err) {\n      if (throwOnError) {\n        throw err\n      }\n    }\n  }\n\n  queryCache.resetErrorBoundaries = () => {\n    queryCache.getQueries(true).forEach(query => {\n      query.state.throwInErrorBoundary = false\n    })\n  }\n\n  queryCache.buildQuery = (userQueryKey, queryFn, config = {}) => {\n    config = {\n      ...configRef.current.shared,\n      ...configRef.current.queries,\n      ...config,\n    }\n\n    let [queryHash, queryKey] = config.queryKeySerializerFn(userQueryKey)\n\n    let query = queryCache.queries[queryHash]\n\n    if (query) {\n      Object.assign(query, { queryFn, config })\n    } else {\n      query = makeQuery({\n        queryCache,\n        queryKey,\n        queryHash,\n        queryFn,\n        config,\n      })\n\n      // If the query started with data, schedule\n      // a stale timeout\n      if (!isServer && query.state.data) {\n        query.scheduleStaleTimeout()\n\n        // Simulate a query healing process\n        query.heal()\n        // Schedule for garbage collection in case\n        // nothing subscribes to this query\n        query.scheduleGarbageCollection()\n      }\n\n      if (!frozen) {\n        queryCache.queries[queryHash] = query\n\n        if (isServer) {\n          notifyGlobalListeners()\n        } else {\n          // Here, we setTimeout so as to not trigger\n          // any setState's in parent components in the\n          // middle of the render phase.\n          setTimeout(() => {\n            notifyGlobalListeners()\n          })\n        }\n      }\n    }\n\n    query.fallbackInstance = {\n      config: {\n        onSuccess: query.config.onSuccess,\n        onError: query.config.onError,\n        onSettled: query.config.onSettled,\n      },\n    }\n\n    return query\n  }\n\n  queryCache.prefetchQuery = async (...args) => {\n    let [\n      queryKey,\n      queryFn,\n      config,\n      { force, throwOnError } = {},\n    ] = getQueryArgs(args)\n\n    try {\n      const query = queryCache.buildQuery(queryKey, queryFn, config)\n      if (force || query.state.isStale) {\n        await query.fetch()\n      }\n      return query.state.data\n    } catch (err) {\n      if (throwOnError) {\n        throw err\n      }\n    }\n  }\n\n  queryCache.setQueryData = (queryKey, updater, config = {}) => {\n    let query = queryCache.getQuery(queryKey)\n\n    if (!query) {\n      query = queryCache.buildQuery(queryKey, () => new Promise(noop), config)\n    }\n\n    query.setData(updater)\n  }\n\n  function makeQuery({ queryCache, queryKey, queryHash, queryFn, config }) {\n    const initialData =\n      typeof config.initialData === 'function'\n        ? config.initialData()\n        : config.initialData\n\n    const hasInitialData = typeof initialData !== 'undefined'\n\n    const isStale = !config.enabled || !hasInitialData\n\n    const initialStatus = hasInitialData\n      ? statusSuccess\n      : config.enabled\n      ? statusLoading\n      : statusIdle\n\n    let query = {\n      queryKey,\n      queryHash,\n      queryFn,\n      config,\n      instances: [],\n      state: queryReducer(undefined, {\n        type: actionInit,\n        initialStatus,\n        initialData,\n        hasInitialData,\n        isStale,\n      }),\n    }\n\n    query.dispatch = action => {\n      query.state = queryReducer(query.state, action)\n      query.instances.forEach(d => d.onStateUpdate(query.state))\n      notifyGlobalListeners()\n    }\n\n    query.scheduleStaleTimeout = () => {\n      if (isServer) return\n      clearTimeout(query.staleTimeout)\n\n      if (query.config.staleTime === Infinity) {\n        return\n      }\n\n      query.staleTimeout = setTimeout(() => {\n        if (queryCache.getQuery(query.queryKey)) {\n          query.invalidate()\n        }\n      }, query.config.staleTime)\n    }\n\n    query.invalidate = () => {\n      clearTimeout(query.staleTimeout)\n      query.dispatch({ type: actionMarkStale })\n    }\n\n    query.scheduleGarbageCollection = () => {\n      if (query.config.cacheTime === Infinity) {\n        return\n      }\n      query.dispatch({ type: actionMarkGC })\n      query.cacheTimeout = setTimeout(\n        () => {\n          queryCache.removeQueries(\n            d =>\n              d.state.markedForGarbageCollection &&\n              d.queryHash === query.queryHash\n          )\n        },\n        typeof query.state.data === 'undefined' &&\n          query.state.status !== 'error'\n          ? 0\n          : query.config.cacheTime\n      )\n    }\n\n    query.heal = () => {\n      // Stop the query from being garbage collected\n      clearTimeout(query.cacheTimeout)\n\n      // Mark the query as not cancelled\n      query.cancelled = null\n    }\n\n    query.cancel = () => {\n      query.cancelled = cancelledError\n\n      if (query.cancelPromises) {\n        query.cancelPromises()\n      }\n\n      delete query.promise\n    }\n\n    query.clearIntervals = () => {\n      query.instances.forEach(instance => {\n        instance.clearInterval()\n      })\n    }\n\n    query.setState = updater =>\n      query.dispatch({ type: actionSetState, updater })\n\n    query.setData = updater => {\n      // Set data and mark it as cached\n      query.dispatch({ type: actionSuccess, updater })\n\n      // Schedule a fresh invalidation!\n      query.scheduleStaleTimeout()\n    }\n\n    query.clear = () => {\n      clearTimeout(query.staleTimeout)\n      clearTimeout(query.cacheTimeout)\n      clearTimeout(query.retryTimeout)\n      query.clearIntervals()\n      query.cancel()\n      query.dispatch = noop\n      delete queryCache.queries[query.queryHash]\n    }\n\n    query.subscribe = (onStateUpdate = noop) => {\n      const instance = {\n        id: uid(),\n        onStateUpdate,\n      }\n\n      query.instances.push(instance)\n\n      query.heal()\n\n      instance.clearInterval = () => {\n        clearInterval(instance.refetchIntervalId)\n        delete instance.refetchIntervalId\n      }\n\n      instance.updateConfig = config => {\n        const oldConfig = instance.config\n\n        // Update the config\n        instance.config = config\n\n        if (!isServer) {\n          if (oldConfig?.refetchInterval === config.refetchInterval) {\n            return\n          }\n\n          query.clearIntervals()\n\n          const minInterval = Math.min(\n            ...query.instances.map(d => d.config.refetchInterval || Infinity)\n          )\n\n          if (\n            !instance.refetchIntervalId &&\n            minInterval > 0 &&\n            minInterval < Infinity\n          ) {\n            instance.refetchIntervalId = setInterval(() => {\n              if (\n                isDocumentVisible() ||\n                query.instances.some(\n                  instance => instance.config.refetchIntervalInBackground\n                )\n              ) {\n                query.fetch()\n              }\n            }, minInterval)\n          }\n        }\n      }\n\n      instance.run = async () => {\n        try {\n          // Perform the refetch for this query if necessary\n          if (\n            query.config.enabled && // Don't auto refetch if disabled\n            !query.wasSuspended && // Don't double refetch for suspense\n            query.state.isStale && // Only refetch if stale\n            (query.config.refetchOnMount || query.instances.length === 1)\n          ) {\n            await query.fetch()\n          }\n\n          query.wasSuspended = false\n        } catch (error) {\n          Console.error(error)\n        }\n      }\n\n      instance.unsubscribe = () => {\n        query.instances = query.instances.filter(d => d.id !== instance.id)\n\n        if (!query.instances.length) {\n          query.clearIntervals()\n          query.cancel()\n\n          if (!isServer) {\n            // Schedule garbage collection\n            query.scheduleGarbageCollection()\n          }\n        }\n      }\n\n      return instance\n    }\n\n    // Set up the core fetcher function\n    const tryFetchData = async (queryFn, ...args) => {\n      try {\n        // Perform the query\n        const promise = queryFn(...query.config.queryFnParamsFilter(args))\n\n        query.cancelPromises = () => promise.cancel?.()\n\n        const data = await promise\n        delete query.shouldContinueRetryOnFocus\n\n        delete query.cancelPromises\n        if (query.cancelled) throw query.cancelled\n\n        return data\n      } catch (error) {\n        delete query.cancelPromises\n        if (query.cancelled) throw query.cancelled\n\n        // If we fail, increase the failureCount\n        query.dispatch({ type: actionFailed })\n\n        // Do we need to retry the request?\n        if (\n          query.config.retry === true ||\n          query.state.failureCount <= query.config.retry ||\n          (typeof query.config.retry === 'function' &&\n            query.config.retry(query.state.failureCount, error))\n        ) {\n          // Only retry if the document is visible\n          if (!isDocumentVisible()) {\n            // set this flag to continue retries on focus\n            query.shouldContinueRetryOnFocus = true\n            return new Promise(noop)\n          }\n\n          delete query.shouldContinueRetryOnFocus\n\n          // Determine the retryDelay\n          const delay = functionalUpdate(\n            query.config.retryDelay,\n            query.state.failureCount\n          )\n\n          // Return a new promise with the retry\n          return await new Promise((resolve, reject) => {\n            // Keep track of the retry timeout\n            query.retryTimeout = setTimeout(async () => {\n              if (query.cancelled) return reject(query.cancelled)\n\n              try {\n                const data = await tryFetchData(queryFn, ...args)\n                if (query.cancelled) return reject(query.cancelled)\n                resolve(data)\n              } catch (error) {\n                if (query.cancelled) return reject(query.cancelled)\n                reject(error)\n              }\n            }, delay)\n          })\n        }\n\n        throw error\n      }\n    }\n\n    query.fetch = async ({ __queryFn = query.queryFn } = {}) => {\n      // Create a new promise for the query cache if necessary\n      if (!query.promise) {\n        query.promise = (async () => {\n          // If there are any retries pending for this query, kill them\n          query.cancelled = null\n\n          const callbackInstances = [...query.instances]\n\n          if (query.wasSuspended) {\n            callbackInstances.unshift(query.fallbackInstance)\n          }\n\n          try {\n            // Set up the query refreshing state\n            query.dispatch({ type: actionFetch })\n\n            // Try to get the data\n            let data = await tryFetchData(__queryFn, ...query.queryKey)\n\n            query.setData(old =>\n              query.config.isDataEqual(old, data) ? old : data\n            )\n\n            callbackInstances.forEach(\n              instance =>\n                instance.config.onSuccess &&\n                instance.config.onSuccess(query.state.data)\n            )\n\n            callbackInstances.forEach(\n              instance =>\n                instance.config.onSettled &&\n                instance.config.onSettled(query.state.data, null)\n            )\n\n            delete query.promise\n\n            return data\n          } catch (error) {\n            query.dispatch({\n              type: actionError,\n              cancelled: error === query.cancelled,\n              error,\n            })\n\n            delete query.promise\n\n            if (error !== query.cancelled) {\n              callbackInstances.forEach(\n                instance =>\n                  instance.config.onError && instance.config.onError(error)\n              )\n\n              callbackInstances.forEach(\n                instance =>\n                  instance.config.onSettled &&\n                  instance.config.onSettled(undefined, error)\n              )\n\n              throw error\n            }\n          }\n        })()\n      }\n\n      return query.promise\n    }\n\n    return query\n  }\n\n  return queryCache\n}\n\nexport function queryReducer(state, action) {\n  const newState = switchActions(state, action)\n\n  Object.assign(newState, {\n    isLoading: newState.status === statusLoading,\n    isSuccess: newState.status === statusSuccess,\n    isError: newState.status === statusError,\n    isIdle: newState.status === statusIdle,\n  })\n\n  return newState\n}\n\nfunction switchActions(state, action) {\n  switch (action.type) {\n    case actionInit:\n      return {\n        status: action.initialStatus,\n        error: null,\n        isFetching: action.initialStatus === 'loading',\n        canFetchMore: false,\n        failureCount: 0,\n        isStale: action.isStale,\n        markedForGarbageCollection: false,\n        data: action.initialData,\n        updatedAt: action.hasInitialData ? Date.now() : 0,\n      }\n    case actionFailed:\n      return {\n        ...state,\n        failureCount: state.failureCount + 1,\n      }\n    case actionMarkStale:\n      return {\n        ...state,\n        isStale: true,\n      }\n    case actionMarkGC: {\n      return {\n        ...state,\n        markedForGarbageCollection: true,\n      }\n    }\n    case actionFetch:\n      return {\n        ...state,\n        status:\n          typeof state.data !== 'undefined' ? statusSuccess : statusLoading,\n        isFetching: true,\n        failureCount: 0,\n      }\n    case actionSuccess:\n      return {\n        ...state,\n        status: statusSuccess,\n        data: functionalUpdate(action.updater, state.data),\n        error: null,\n        isStale: false,\n        isFetching: false,\n        canFetchMore: action.canFetchMore,\n        updatedAt: Date.now(),\n        failureCount: 0,\n      }\n    case actionError:\n      return {\n        ...state,\n        isFetching: false,\n        isStale: true,\n        ...(!action.cancelled && {\n          status: statusError,\n          error: action.error,\n          throwInErrorBoundary: true,\n        }),\n      }\n    case actionSetState:\n      return functionalUpdate(action.updater, state)\n    default:\n      throw new Error()\n  }\n}\n","import { isOnline, isDocumentVisible, Console, isServer } from './utils'\nimport { queryCaches } from './queryCache'\n\nconst visibilityChangeEvent = 'visibilitychange'\nconst focusEvent = 'focus'\n\nconst onWindowFocus = () => {\n  if (isDocumentVisible() && isOnline()) {\n    queryCaches.forEach(queryCache =>\n      queryCache\n        .invalidateQueries(query => {\n          if (!query.instances.length) {\n            return false\n          }\n\n          if (!query.instances.some(instance => instance.config.enabled)) {\n            return false\n          }\n\n          if (!query.state.isStale) {\n            return false\n          }\n\n          if (query.shouldContinueRetryOnFocus) {\n            // delete promise, so refetching will create new one\n            delete query.promise\n          }\n\n          return query.config.refetchOnWindowFocus\n        })\n        .catch(Console.error)\n    )\n  }\n}\n\nlet removePreviousHandler\n\nexport function setFocusHandler(callback) {\n  // Unsub the old watcher\n  if (removePreviousHandler) {\n    removePreviousHandler()\n  }\n  // Sub the new watcher\n  removePreviousHandler = callback(onWindowFocus)\n}\n\nsetFocusHandler(handleFocus => {\n  // Listen to visibillitychange and focus\n  if (!isServer && window?.addEventListener) {\n    window.addEventListener(visibilityChangeEvent, handleFocus, false)\n    window.addEventListener(focusEvent, handleFocus, false)\n\n    return () => {\n      // Be sure to unsubscribe if a new handler is set\n      window.removeEventListener(visibilityChangeEvent, handleFocus)\n      window.removeEventListener(focusEvent, handleFocus)\n    }\n  }\n})\n","import React from 'react'\n\nimport { useMountedCallback } from './utils'\nimport { useQueryCache } from './queryCache'\n\nexport function useIsFetching() {\n  const queryCache = useQueryCache()\n  const [state, unsafeRerender] = React.useReducer(d => d + 1, 1)\n  const rerender = useMountedCallback(unsafeRerender)\n\n  React.useEffect(() => queryCache.subscribe(rerender), [queryCache, rerender])\n\n  return React.useMemo(() => state && queryCache.isFetching, [\n    queryCache.isFetching,\n    state,\n  ])\n}\n","import React from 'react'\n\n//\n\nimport { useConfigContext } from './config'\nimport {\n  statusIdle,\n  statusLoading,\n  statusSuccess,\n  statusError,\n  useGetLatest,\n  Console,\n  uid,\n  useMountedCallback,\n  noop,\n} from './utils'\n\nconst getDefaultState = () => ({\n  status: statusIdle,\n  data: undefined,\n  error: null,\n})\n\nconst actionReset = {}\nconst actionLoading = {}\nconst actionResolve = {}\nconst actionReject = {}\n\nfunction mutationReducer(state, action) {\n  if (action.type === actionReset) {\n    return getDefaultState()\n  }\n  if (action.type === actionLoading) {\n    return {\n      status: statusLoading,\n    }\n  }\n  if (action.type === actionResolve) {\n    return {\n      status: statusSuccess,\n      data: action.data,\n    }\n  }\n  if (action.type === actionReject) {\n    return {\n      status: statusError,\n      error: action.error,\n    }\n  }\n  throw new Error()\n}\n\nexport function useMutation(mutationFn, config = {}) {\n  const [state, unsafeDispatch] = React.useReducer(\n    mutationReducer,\n    null,\n    getDefaultState\n  )\n\n  const dispatch = useMountedCallback(unsafeDispatch)\n\n  const getMutationFn = useGetLatest(mutationFn)\n\n  const getConfig = useGetLatest({\n    ...useConfigContext().shared,\n    ...useConfigContext().mutations,\n    ...config,\n  })\n\n  const latestMutationRef = React.useRef()\n\n  const mutate = React.useCallback(\n    async (\n      variables,\n      { onSuccess = noop, onError = noop, onSettled = noop, throwOnError } = {}\n    ) => {\n      const config = getConfig()\n\n      const mutationId = uid()\n      latestMutationRef.current = mutationId\n\n      const isLatest = () => latestMutationRef.current === mutationId\n\n      dispatch({ type: actionLoading })\n\n      let snapshotValue\n\n      try {\n        snapshotValue = await config.onMutate(variables)\n\n        let data\n\n        if (isLatest()) {\n          data = await getMutationFn()(variables)\n        }\n\n        if (isLatest()) {\n          dispatch({ type: actionResolve, data })\n        }\n\n        if (isLatest()) {\n          await config.onSuccess(data, variables)\n        }\n\n        if (isLatest()) {\n          await onSuccess(data, variables)\n        }\n\n        if (isLatest()) {\n          await config.onSettled(data, null, variables)\n        }\n\n        if (isLatest()) {\n          await onSettled(data, null, variables)\n        }\n\n        return data\n      } catch (error) {\n        if (isLatest()) {\n          Console.error(error)\n          await config.onError(error, variables, snapshotValue)\n        }\n\n        if (isLatest()) {\n          await onError(error, variables, snapshotValue)\n        }\n\n        if (isLatest()) {\n          await config.onSettled(undefined, error, variables, snapshotValue)\n        }\n\n        if (isLatest()) {\n          await onSettled(undefined, error, variables, snapshotValue)\n        }\n\n        if (isLatest()) {\n          dispatch({ type: actionReject, error })\n\n          if (throwOnError ?? config.throwOnError) {\n            throw error\n          }\n        }\n      }\n    },\n    [dispatch, getConfig, getMutationFn]\n  )\n\n  const reset = React.useCallback(() => dispatch({ type: actionReset }), [\n    dispatch,\n  ])\n\n  React.useEffect(() => {\n    const { suspense, useErrorBoundary } = getConfig()\n\n    if ((useErrorBoundary ?? suspense) && state.error) {\n      throw state.error\n    }\n  }, [getConfig, state.error])\n\n  return [\n    mutate,\n    {\n      ...state,\n      reset,\n      isIdle: state.status === statusIdle,\n      isLoading: state.status === statusLoading,\n      isSuccess: state.status === statusSuccess,\n      isError: state.status === statusError,\n    },\n  ]\n}\n","import React from 'react'\n\n//\n\nimport { useQueryCache } from './queryCache'\nimport { useConfigContext } from './config'\nimport { useMountedCallback, Console } from './utils'\n\nexport function useBaseQuery(queryKey, queryFn, config = {}) {\n  // Make a rerender function\n  const rerender = useMountedCallback(React.useState()[1])\n\n  // Build the final config\n  const configContext = useConfigContext()\n\n  config = {\n    ...configContext.shared,\n    ...configContext.queries,\n    ...config,\n  }\n\n  // Get the query cache\n  const queryCache = useQueryCache()\n\n  // Build the query for use\n  const query = queryCache.buildQuery(queryKey, queryFn, config)\n\n  // Create a query instance ref\n  const instanceRef = React.useRef()\n\n  // Subscribe to the query when the subscribe function changes\n  React.useEffect(() => {\n    instanceRef.current = query.subscribe(() => rerender({}))\n\n    // Unsubscribe when things change\n    return instanceRef.current.unsubscribe\n  }, [query, rerender])\n\n  // Always update the config\n  React.useEffect(() => {\n    instanceRef.current.updateConfig(config)\n  })\n\n  // Run the instance when the query or enabled change\n  React.useEffect(() => {\n    if (config.enabled && query) {\n      // Just for change detection\n    }\n    instanceRef.current.run()\n  }, [config.enabled, query])\n\n  const refetch = React.useCallback(async () => {\n    try {\n      await query.fetch()\n    } catch (error) {\n      Console.error(error)\n    }\n  }, [query])\n\n  return {\n    query,\n    refetch,\n    ...query.state,\n  }\n}\n","import { useBaseQuery } from './useBaseQuery'\nimport { getQueryArgs, handleSuspense } from './utils'\n\nexport function useQuery(...args) {\n  const query = useBaseQuery(...getQueryArgs(args))\n\n  handleSuspense(query)\n\n  return query\n}\n","import React from 'react'\n\n//\n\nimport { useBaseQuery } from './useBaseQuery'\nimport { getQueryArgs, handleSuspense } from './utils'\n\nexport function usePaginatedQuery(...args) {\n  let [queryKey, queryFn, config = {}] = getQueryArgs(args)\n\n  const lastDataRef = React.useRef()\n\n  // If latestData is set, don't use initialData\n  if (typeof lastDataRef.current !== 'undefined') {\n    delete config.initialData\n  }\n\n  const queryInfo = useBaseQuery(queryKey, queryFn, config)\n\n  if (!queryInfo.query.config.enabled) {\n    lastDataRef.current = undefined\n  }\n\n  let { data: latestData, status } = queryInfo\n\n  React.useEffect(() => {\n    if (status === 'success' && typeof latestData !== 'undefined') {\n      lastDataRef.current = latestData\n    }\n  }, [latestData, status])\n\n  let resolvedData = latestData\n\n  if (typeof resolvedData === 'undefined') {\n    resolvedData = lastDataRef.current\n  }\n\n  if (typeof resolvedData !== 'undefined') {\n    const overrides = {\n      status: 'success',\n      isError: false,\n      isLoading: false,\n      isSuccess: true,\n    }\n\n    Object.assign(queryInfo.query.state, overrides)\n    Object.assign(queryInfo, overrides)\n  }\n\n  const paginatedQueryInfo = {\n    ...queryInfo,\n    resolvedData,\n    latestData,\n  }\n\n  handleSuspense(paginatedQueryInfo)\n\n  return paginatedQueryInfo\n}\n","import React from 'react'\n\n//\n\nimport { useBaseQuery } from './useBaseQuery'\nimport { getQueryArgs, useGetLatest, handleSuspense } from './utils'\n\nexport function useInfiniteQuery(...args) {\n  const queryInfoRef = React.useRef()\n  let [queryKey, queryFn, config = {}] = getQueryArgs(args)\n\n  const { getFetchMore } = config\n  const getGetFetchMore = useGetLatest(getFetchMore)\n\n  // The default queryFn will query all pages and map them together\n  const originalQueryFn = queryFn\n\n  queryFn = async () => {\n    const data = []\n    const pageVariables = [...queryInfoRef.current.query.pageVariables]\n    const rebuiltPageVariables = []\n\n    do {\n      const args = pageVariables.shift()\n\n      if (!data.length) {\n        // the first page query doesn't need to be rebuilt\n        data.push(await originalQueryFn(...args))\n        rebuiltPageVariables.push(args)\n      } else {\n        // get an up-to-date cursor based on the previous data set\n        const nextCursor = getGetFetchMore()(data[data.length - 1], data)\n\n        // break early if there's no next cursor\n        // otherwise we'll start from the beginning\n        // which will cause unwanted duplication\n        if (!nextCursor) {\n          break\n        }\n\n        const pageArgs = [\n          // remove the last argument (the previously saved cursor)\n          ...args.slice(0, -1),\n          nextCursor,\n        ]\n\n        data.push(await originalQueryFn(...pageArgs))\n        rebuiltPageVariables.push(pageArgs)\n      }\n    } while (pageVariables.length)\n\n    queryInfoRef.current.query.canFetchMore = getGetFetchMore()(\n      data[data.length - 1],\n      data\n    )\n    queryInfoRef.current.query.pageVariables = rebuiltPageVariables\n\n    return data\n  }\n\n  const queryInfo = useBaseQuery(queryKey, queryFn, config)\n\n  if (\n    typeof queryInfo.query.canFetchMore === 'undefined' &&\n    typeof queryInfo.data !== 'undefined'\n  ) {\n    queryInfo.query.canFetchMore = getGetFetchMore()(\n      queryInfo.data[queryInfo.data.length - 1],\n      queryInfo.data\n    )\n  }\n\n  queryInfoRef.current = queryInfo\n\n  let {\n    data = [],\n    query: { canFetchMore },\n  } = queryInfo\n\n  // Here we seed the pageVariabes for the query\n  if (!queryInfo.query.pageVariables) {\n    queryInfo.query.pageVariables = [[...queryInfo.query.queryKey]]\n  }\n\n  const fetchMore = React.useCallback(\n    (\n      fetchMoreInfo = queryInfoRef.current.query.canFetchMore,\n      { previous = false } = {}\n    ) =>\n      queryInfoRef.current.query.canFetchMore\n        ? queryInfoRef.current.query.fetch({\n            __queryFn: async (...args) => {\n              try {\n                queryInfoRef.current.query.setState(old => ({\n                  ...old,\n                  isFetchingMore: previous ? 'previous' : 'next',\n                }))\n\n                const newArgs = previous\n                  ? [fetchMoreInfo, ...args]\n                  : [...args, fetchMoreInfo]\n                queryInfoRef.current.query.pageVariables[\n                  previous ? 'unshift' : 'push'\n                ](newArgs)\n\n                const newData = await originalQueryFn(...newArgs)\n\n                const data = previous\n                  ? [newData, ...queryInfoRef.current.data]\n                  : [...queryInfoRef.current.data, newData]\n\n                queryInfoRef.current.query.canFetchMore = getGetFetchMore()(\n                  newData,\n                  data\n                )\n\n                return data\n              } finally {\n                queryInfoRef.current.query.setState(old => ({\n                  ...old,\n                  isFetchingMore: false,\n                }))\n              }\n            },\n          })\n        : void 0,\n    [getGetFetchMore, originalQueryFn]\n  )\n\n  handleSuspense(queryInfo)\n\n  return {\n    ...queryInfo,\n    data,\n    canFetchMore,\n    fetchMore,\n  }\n}\n"],"names":["statusIdle","statusLoading","statusError","statusSuccess","_uid","uid","cancelledError","isServer","window","noop","Console","console","error","warn","log","setConsole","c","useGetLatest","obj","ref","React","useRef","current","useCallback","functionalUpdate","updater","old","stableStringifyReplacer","_","value","isObject","Object","assign","keys","sort","map","key","stableStringify","JSON","stringify","a","Array","isArray","deepIncludes","b","some","isDocumentVisible","document","undefined","visibilityState","getQueryArgs","args","hasOwnProperty","queryKey","queryFn","config","slice","Error","rest","useMountedCallback","callback","mounted","handleSuspense","queryInfo","query","suspense","useErrorBoundary","state","status","throwInErrorBoundary","wasSuspended","fetch","configContext","createContext","DEFAULTS","shared","queryKeySerializerFn","invalidQueryKey","d","queryHash","parse","queries","enabled","retry","retryDelay","attemptIndex","Math","min","staleTime","cacheTime","refetchOnWindowFocus","refetchInterval","queryFnParamsFilter","refetchOnMount","isDataEqual","deepEqual","length","i","valueOf","prototype","call","onError","onSuccess","onSettled","mutations","throwOnError","onMutate","defaultConfigRef","useConfigContext","useContext","ReactQueryConfigProvider","children","configContextValue","newConfig","useMemo","contextShared","contextQueries","contextMutations","useEffect","Provider","then","direct","Promise","resolve","body","recover","result","e","f","arguments","apply","this","reject","queryCache","makeQueryCache","queryCacheContext","queryCaches","useQueryCache","ReactQueryCacheProvider","resolvedQueryCache","push","indexOf","splice","clear","frozen","defaultConfig","globalListeners","configRef","isFetching","notifyGlobalListeners","values","reduce","acc","forEach","subscribe","cb","notify","getQueries","predicate","exact","filter","getQuery","getQueryData","_queryCache$getQuery","data","removeQueries","cancelQueries","cancel","invalidateQueries","refetchActive","all","instances","invalidate","err","resetErrorBoundaries","buildQuery","userQueryKey","initialData","hasInitialData","isStale","initialStatus","queryReducer","type","dispatch","action","onStateUpdate","scheduleStaleTimeout","clearTimeout","staleTimeout","Infinity","setTimeout","scheduleGarbageCollection","cacheTimeout","markedForGarbageCollection","heal","cancelled","cancelPromises","promise","clearIntervals","instance","clearInterval","setState","setData","retryTimeout","id","refetchIntervalId","updateConfig","oldConfig","minInterval","setInterval","refetchIntervalInBackground","run","unsubscribe","tryFetchData","shouldContinueRetryOnFocus","failureCount","delay","__queryFn","_async","callbackInstances","unshift","fallbackInstance","makeQuery","prefetchQuery","force","setQueryData","newState","canFetchMore","updatedAt","Date","now","switchActions","isLoading","isSuccess","isError","isIdle","removePreviousHandler","onWindowFocus","navigator","onLine","catch","setFocusHandler","useIsFetching","useReducer","rerender","_await","handleFocus","_window","addEventListener","removeEventListener","getDefaultState","_empty","actionReset","_awaitIgnored","actionLoading","_invoke","actionResolve","actionReject","mutationReducer","useMutation","mutationFn","getMutationFn","getConfig","latestMutationRef","mutate","variables","mutationId","snapshotValue","isLatest","reset","useBaseQuery","useState","instanceRef","refetch","useQuery","usePaginatedQuery","lastDataRef","latestData","resolvedData","overrides","paginatedQueryInfo","pact","s","o","_settle","bind","v","observer","_Pact","onFulfilled","onRejected","_this","thenable","test","awaitBody","_isSettledPact","shouldContinue","_resumeAfterBody","_resumeAfterTest","thrown","finalizer","useInfiniteQuery","queryInfoRef","getFetchMore","getGetFetchMore","originalQueryFn","pageVariables","rebuiltPageVariables","shift","nextCursor","pageArgs","fetchMore","fetchMoreInfo","previous","isFetchingMore","newArgs","newData"],"mappings":"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"}