(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('react')) :
  typeof define === 'function' && define.amd ? define(['exports', 'react'], factory) :
  (global = global || self, factory(global.ReactQuery = {}, global.React));
}(this, (function (exports, React) { 'use strict';

  React = React && Object.prototype.hasOwnProperty.call(React, 'default') ? React['default'] : React;

  function _extends() {
    _extends = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    return _extends.apply(this, arguments);
  }

  var statusIdle = 'idle';
  var statusLoading = 'loading';
  var statusError = 'error';
  var statusSuccess = 'success';
  var _uid = 0;
  var uid = function uid() {
    return _uid++;
  };
  var cancelledError = {};
  var isServer = typeof window === 'undefined';
  var noop = function noop() {};
  var identity = function identity(d) {
    return d;
  };
  var Console = console || {
    error: noop,
    warn: noop,
    log: noop
  };
  function setConsole(c) {
    Console = c;
  }
  function useGetLatest(obj) {
    var ref = React.useRef();
    ref.current = obj;
    return React.useCallback(function () {
      return ref.current;
    }, []);
  }
  function functionalUpdate(updater, old) {
    return typeof updater === 'function' ? updater(old) : updater;
  }
  function stableStringifyReplacer(_, value) {
    return isObject(value) ? Object.assign.apply(Object, [{}].concat(Object.keys(value).sort().map(function (key) {
      var _ref;

      return _ref = {}, _ref[key] = value[key], _ref;
    }))) : value;
  }
  function stableStringify(obj) {
    return JSON.stringify(obj, stableStringifyReplacer);
  }
  function isObject(a) {
    return a && typeof a === 'object' && !Array.isArray(a);
  }
  function deepIncludes(a, b) {
    if (a === b) {
      return true;
    }

    if (typeof a !== typeof b) {
      return false;
    }

    if (typeof a === 'object') {
      return !Object.keys(b).some(function (key) {
        return !deepIncludes(a[key], b[key]);
      });
    }

    return false;
  }
  function isDocumentVisible() {
    return typeof document === 'undefined' || document.visibilityState === undefined || document.visibilityState === 'visible' || document.visibilityState === 'prerender';
  }
  function isOnline() {
    return navigator.onLine === undefined || navigator.onLine;
  }
  function getQueryArgs(args) {
    if (isObject(args[0])) {
      if (args[0].hasOwnProperty('queryKey') && args[0].hasOwnProperty('queryFn')) {
        var _args$ = args[0],
            _queryKey = _args$.queryKey,
            _queryFn = _args$.queryFn,
            _args$$config = _args$.config,
            _config = _args$$config === void 0 ? {} : _args$$config;

        return [_queryKey, _queryFn, _config].concat(args.slice(1));
      } else {
        throw new Error('queryKey and queryFn keys are required.');
      }
    }

    var queryKey = args[0],
        queryFn = args[1],
        _args$2 = args[2],
        config = _args$2 === void 0 ? {} : _args$2,
        rest = args.slice(3);
    return [queryKey, queryFn, config].concat(rest);
  }
  function useMountedCallback(callback) {
    var mounted = React.useRef(false);
    React[isServer ? 'useEffect' : 'useLayoutEffect'](function () {
      mounted.current = true;
      return function () {
        return mounted.current = false;
      };
    }, []);
    return React.useCallback(function () {
      return mounted.current ? callback.apply(void 0, arguments) : void 0;
    }, [callback]);
  }
  function handleSuspense(queryInfo) {
    if (queryInfo.query.config.suspense || queryInfo.query.config.useErrorBoundary) {
      if (queryInfo.query.state.status === statusError && queryInfo.query.state.throwInErrorBoundary) {
        throw queryInfo.error;
      }

      if (queryInfo.query.config.suspense && queryInfo.status !== statusSuccess) {
        queryInfo.query.wasSuspended = true;
        throw queryInfo.query.fetch();
      }
    }
  } // This deep-equal is directly based on https://github.com/epoberezkin/fast-deep-equal.
  // The parts for comparing any non-JSON-supported values has been removed

  function deepEqual(a, b) {
    if (a === b) return true;

    if (a && b && typeof a == 'object' && typeof b == 'object') {
      var length, i, keys;

      if (Array.isArray(a)) {
        length = a.length; // eslint-disable-next-line eqeqeq

        if (length != b.length) return false;

        for (i = length; i-- !== 0;) {
          if (!deepEqual(a[i], b[i])) return false;
        }

        return true;
      }

      if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
      keys = Object.keys(a);
      length = keys.length;
      if (length !== Object.keys(b).length) return false;

      for (i = length; i-- !== 0;) {
        if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;
      }

      for (i = length; i-- !== 0;) {
        var key = keys[i];
        if (!deepEqual(a[key], b[key])) return false;
      }

      return true;
    } // true if both NaN, false otherwise
    // eslint-disable-next-line no-self-compare


    return a !== a && b !== b;
  }

  var configContext = React.createContext();
  var DEFAULTS = {
    shared: {
      suspense: false,
      queryKeySerializerFn: defaultQueryKeySerializerFn
    },
    queries: {
      enabled: true,
      retry: 3,
      retryDelay: function retryDelay(attemptIndex) {
        return Math.min(1000 * Math.pow(2, attemptIndex), 30000);
      },
      staleTime: 0,
      cacheTime: 5 * 60 * 1000,
      refetchOnWindowFocus: true,
      refetchInterval: false,
      queryFnParamsFilter: identity,
      refetchOnMount: true,
      isDataEqual: deepEqual,
      onError: noop,
      onSuccess: noop,
      onSettled: noop,
      useErrorBoundary: false
    },
    mutations: {
      throwOnError: false,
      onMutate: noop,
      onError: noop,
      onSuccess: noop,
      onSettled: noop,
      useErrorBoundary: false
    }
  };
  var defaultConfigRef = {
    current: DEFAULTS
  };
  function useConfigContext() {
    return React.useContext(configContext) || defaultConfigRef.current;
  }
  function ReactQueryConfigProvider(_ref) {
    var config = _ref.config,
        children = _ref.children;
    var configContextValue = useConfigContext();
    var newConfig = React.useMemo(function () {
      var _config$shared = config.shared,
          shared = _config$shared === void 0 ? {} : _config$shared,
          _config$queries = config.queries,
          queries = _config$queries === void 0 ? {} : _config$queries,
          _config$mutations = config.mutations,
          mutations = _config$mutations === void 0 ? {} : _config$mutations;
      var _configContextValue$s = configContextValue.shared,
          contextShared = _configContextValue$s === void 0 ? {} : _configContextValue$s,
          _configContextValue$q = configContextValue.queries,
          contextQueries = _configContextValue$q === void 0 ? {} : _configContextValue$q,
          _configContextValue$m = configContextValue.mutations,
          contextMutations = _configContextValue$m === void 0 ? {} : _configContextValue$m;
      return {
        shared: _extends({}, contextShared, shared),
        queries: _extends({}, contextQueries, queries),
        mutations: _extends({}, contextMutations, mutations)
      };
    }, [config, configContextValue]);
    React.useEffect(function () {
      // restore previous config on unmount
      return function () {
        defaultConfigRef.current = _extends({}, configContextValue || DEFAULTS);
      };
    }, [configContextValue]);

    if (!configContextValue) {
      defaultConfigRef.current = newConfig;
    }

    return /*#__PURE__*/React.createElement(configContext.Provider, {
      value: newConfig
    }, children);
  }

  function invalidQueryKey() {
    throw new Error('A valid query key is required!');
  }

  function defaultQueryKeySerializerFn(queryKey) {
    if (!queryKey) {
      invalidQueryKey();
    }

    if (!Array.isArray(queryKey)) {
      queryKey = [queryKey];
    }

    if (queryKey.some(function (d) {
      return typeof d === 'function';
    })) {
      invalidQueryKey();
    }

    var queryHash = stableStringify(queryKey);
    queryKey = JSON.parse(queryHash);

    if (!queryHash) {
      invalidQueryKey();
    }

    return [queryHash, queryKey];
  }

  function _await(value, then, direct) {
    if (direct) {
      return then ? then(value) : value;
    }

    if (!value || !value.then) {
      value = Promise.resolve(value);
    }

    return then ? value.then(then) : value;
  }

  function _catch(body, recover) {
    try {
      var result = body();
    } catch (e) {
      return recover(e);
    }

    if (result && result.then) {
      return result.then(void 0, recover);
    }

    return result;
  }

  function _async(f) {
    return function () {
      for (var args = [], i = 0; i < arguments.length; i++) {
        args[i] = arguments[i];
      }

      try {
        return Promise.resolve(f.apply(this, args));
      } catch (e) {
        return Promise.reject(e);
      }
    };
  }

  function _empty() {}

  function _awaitIgnored(value, direct) {
    if (!direct) {
      return value && value.then ? value.then(_empty) : Promise.resolve();
    }
  }

  function _invoke(body, then) {
    var result = body();

    if (result && result.then) {
      return result.then(then);
    }

    return then(result);
  }

  function _continueIgnored(value) {
    if (value && value.then) {
      return value.then(_empty);
    }
  }

  var queryCache = makeQueryCache();
  var queryCacheContext = React.createContext(queryCache);
  var queryCaches = [queryCache];
  var useQueryCache = function useQueryCache() {
    return React.useContext(queryCacheContext);
  };
  function ReactQueryCacheProvider(_ref) {
    var queryCache = _ref.queryCache,
        children = _ref.children;
    var resolvedQueryCache = React.useMemo(function () {
      return queryCache || makeQueryCache();
    }, [queryCache]);
    React.useEffect(function () {
      queryCaches.push(resolvedQueryCache);
      return function () {
        // remove the cache from the active list
        var i = queryCaches.indexOf(resolvedQueryCache);

        if (i > -1) {
          queryCaches.splice(i, 1);
        } // if the resolvedQueryCache was created by us, we need to tear it down


        if (queryCache == null) {
          resolvedQueryCache.clear();
        }
      };
    }, [resolvedQueryCache, queryCache]);
    return /*#__PURE__*/React.createElement(queryCacheContext.Provider, {
      value: resolvedQueryCache
    }, children);
  }
  var actionInit = 'Init';
  var actionFailed = 'Failed';
  var actionMarkStale = 'MarkStale';
  var actionMarkGC = 'MarkGC';
  var actionFetch = 'Fetch';
  var actionSuccess = 'Success';
  var actionError = 'Error';
  var actionSetState = 'SetState';
  function makeQueryCache(_temp) {
    var _ref2 = _temp === void 0 ? {} : _temp,
        _ref2$frozen = _ref2.frozen,
        frozen = _ref2$frozen === void 0 ? isServer : _ref2$frozen,
        defaultConfig = _ref2.defaultConfig;

    // A frozen cache does not add new queries to the cache
    var globalListeners = [];
    var configRef = defaultConfig ? {
      current: defaultConfig
    } : defaultConfigRef;
    var queryCache = {
      queries: {},
      isFetching: 0
    };

    var notifyGlobalListeners = function notifyGlobalListeners() {
      queryCache.isFetching = Object.values(queryCache.queries).reduce(function (acc, query) {
        return query.state.isFetching ? acc + 1 : acc;
      }, 0);
      globalListeners.forEach(function (d) {
        return d(queryCache);
      });
    };

    queryCache.subscribe = function (cb) {
      globalListeners.push(cb);
      return function () {
        globalListeners.splice(globalListeners.indexOf(cb), 1);
      };
    };

    queryCache.clear = function (_temp2) {
      var _ref3 = _temp2 === void 0 ? {} : _temp2,
          _ref3$notify = _ref3.notify,
          notify = _ref3$notify === void 0 ? true : _ref3$notify;

      Object.values(queryCache.queries).forEach(function (query) {
        return query.clear();
      });
      queryCache.queries = {};

      if (notify) {
        notifyGlobalListeners();
      }
    };

    queryCache.getQueries = function (predicate, _temp3) {
      var _ref4 = _temp3 === void 0 ? {} : _temp3,
          exact = _ref4.exact;

      if (predicate === true) {
        return Object.values(queryCache.queries);
      }

      if (typeof predicate !== 'function') {
        var _configRef$current$sh = configRef.current.shared.queryKeySerializerFn(predicate),
            queryHash = _configRef$current$sh[0],
            queryKey = _configRef$current$sh[1];

        predicate = function predicate(d) {
          return exact ? d.queryHash === queryHash : deepIncludes(d.queryKey, queryKey);
        };
      }

      return Object.values(queryCache.queries).filter(predicate);
    };

    queryCache.getQuery = function (queryKey) {
      return queryCache.getQueries(queryKey, {
        exact: true
      })[0];
    };

    queryCache.getQueryData = function (queryKey) {
      var _queryCache$getQuery;

      return (_queryCache$getQuery = queryCache.getQuery(queryKey)) == null ? void 0 : _queryCache$getQuery.state.data;
    };

    queryCache.removeQueries = function () {
      queryCache.getQueries.apply(queryCache, arguments).forEach(function (query) {
        return query.clear();
      });
    };

    queryCache.cancelQueries = function () {
      queryCache.getQueries.apply(queryCache, arguments).forEach(function (query) {
        return query.cancel();
      });
    };

    queryCache.invalidateQueries = _async(function (predicate, _temp4) {
      var _ref5 = _temp4 === void 0 ? {} : _temp4,
          _ref5$refetchActive = _ref5.refetchActive,
          refetchActive = _ref5$refetchActive === void 0 ? true : _ref5$refetchActive,
          exact = _ref5.exact,
          throwOnError = _ref5.throwOnError;

      return _catch(function () {
        return _await(Promise.all(queryCache.getQueries(predicate, {
          exact: exact
        }).map(function (query) {
          if (refetchActive && query.instances.length) {
            return query.fetch();
          }

          return query.invalidate();
        })));
      }, function (err) {
        if (throwOnError) {
          throw err;
        }
      });
    });

    queryCache.resetErrorBoundaries = function () {
      queryCache.getQueries(true).forEach(function (query) {
        query.state.throwInErrorBoundary = false;
      });
    };

    queryCache.buildQuery = function (userQueryKey, queryFn, config) {
      if (config === void 0) {
        config = {};
      }

      config = _extends({}, configRef.current.shared, configRef.current.queries, config);

      var _config$queryKeySeria = config.queryKeySerializerFn(userQueryKey),
          queryHash = _config$queryKeySeria[0],
          queryKey = _config$queryKeySeria[1];

      var query = queryCache.queries[queryHash];

      if (query) {
        Object.assign(query, {
          queryFn: queryFn,
          config: config
        });
      } else {
        query = makeQuery({
          queryCache: queryCache,
          queryKey: queryKey,
          queryHash: queryHash,
          queryFn: queryFn,
          config: config
        }); // If the query started with data, schedule
        // a stale timeout

        if (!isServer && query.state.data) {
          query.scheduleStaleTimeout(); // Simulate a query healing process

          query.heal(); // Schedule for garbage collection in case
          // nothing subscribes to this query

          query.scheduleGarbageCollection();
        }

        if (!frozen) {
          queryCache.queries[queryHash] = query;

          if (isServer) {
            notifyGlobalListeners();
          } else {
            // Here, we setTimeout so as to not trigger
            // any setState's in parent components in the
            // middle of the render phase.
            setTimeout(function () {
              notifyGlobalListeners();
            });
          }
        }
      }

      query.fallbackInstance = {
        config: {
          onSuccess: query.config.onSuccess,
          onError: query.config.onError,
          onSettled: query.config.onSettled
        }
      };
      return query;
    };

    queryCache.prefetchQuery = _async(function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      var _getQueryArgs = getQueryArgs(args),
          queryKey = _getQueryArgs[0],
          queryFn = _getQueryArgs[1],
          config = _getQueryArgs[2],
          _getQueryArgs$ = _getQueryArgs[3];

      _getQueryArgs$ = _getQueryArgs$ === void 0 ? {} : _getQueryArgs$;
      var force = _getQueryArgs$.force,
          throwOnError = _getQueryArgs$.throwOnError;
      return _catch(function () {
        var query = queryCache.buildQuery(queryKey, queryFn, config);
        return _invoke(function () {
          if (force || query.state.isStale) {
            return _awaitIgnored(query.fetch());
          }
        }, function () {
          return query.state.data;
        });
      }, function (err) {
        if (throwOnError) {
          throw err;
        }
      });
    });

    queryCache.setQueryData = function (queryKey, updater, config) {
      if (config === void 0) {
        config = {};
      }

      var query = queryCache.getQuery(queryKey);

      if (!query) {
        query = queryCache.buildQuery(queryKey, function () {
          return new Promise(noop);
        }, config);
      }

      query.setData(updater);
    };

    function makeQuery(_ref6) {
      var queryCache = _ref6.queryCache,
          queryKey = _ref6.queryKey,
          queryHash = _ref6.queryHash,
          queryFn = _ref6.queryFn,
          config = _ref6.config;
      var initialData = typeof config.initialData === 'function' ? config.initialData() : config.initialData;
      var hasInitialData = typeof initialData !== 'undefined';
      var isStale = !config.enabled || !hasInitialData;
      var initialStatus = hasInitialData ? statusSuccess : config.enabled ? statusLoading : statusIdle;
      var query = {
        queryKey: queryKey,
        queryHash: queryHash,
        queryFn: queryFn,
        config: config,
        instances: [],
        state: queryReducer(undefined, {
          type: actionInit,
          initialStatus: initialStatus,
          initialData: initialData,
          hasInitialData: hasInitialData,
          isStale: isStale
        })
      };

      query.dispatch = function (action) {
        query.state = queryReducer(query.state, action);
        query.instances.forEach(function (d) {
          return d.onStateUpdate(query.state);
        });
        notifyGlobalListeners();
      };

      query.scheduleStaleTimeout = function () {
        if (isServer) return;
        clearTimeout(query.staleTimeout);

        if (query.config.staleTime === Infinity) {
          return;
        }

        query.staleTimeout = setTimeout(function () {
          if (queryCache.getQuery(query.queryKey)) {
            query.invalidate();
          }
        }, query.config.staleTime);
      };

      query.invalidate = function () {
        clearTimeout(query.staleTimeout);
        query.dispatch({
          type: actionMarkStale
        });
      };

      query.scheduleGarbageCollection = function () {
        if (query.config.cacheTime === Infinity) {
          return;
        }

        query.dispatch({
          type: actionMarkGC
        });
        query.cacheTimeout = setTimeout(function () {
          queryCache.removeQueries(function (d) {
            return d.state.markedForGarbageCollection && d.queryHash === query.queryHash;
          });
        }, typeof query.state.data === 'undefined' && query.state.status !== 'error' ? 0 : query.config.cacheTime);
      };

      query.heal = function () {
        // Stop the query from being garbage collected
        clearTimeout(query.cacheTimeout); // Mark the query as not cancelled

        query.cancelled = null;
      };

      query.cancel = function () {
        query.cancelled = cancelledError;

        if (query.cancelPromises) {
          query.cancelPromises();
        }

        delete query.promise;
      };

      query.clearIntervals = function () {
        query.instances.forEach(function (instance) {
          instance.clearInterval();
        });
      };

      query.setState = function (updater) {
        return query.dispatch({
          type: actionSetState,
          updater: updater
        });
      };

      query.setData = function (updater) {
        // Set data and mark it as cached
        query.dispatch({
          type: actionSuccess,
          updater: updater
        }); // Schedule a fresh invalidation!

        query.scheduleStaleTimeout();
      };

      query.clear = function () {
        clearTimeout(query.staleTimeout);
        clearTimeout(query.cacheTimeout);
        clearTimeout(query.retryTimeout);
        query.clearIntervals();
        query.cancel();
        query.dispatch = noop;
        delete queryCache.queries[query.queryHash];
      };

      query.subscribe = function (onStateUpdate) {
        if (onStateUpdate === void 0) {
          onStateUpdate = noop;
        }

        var instance = {
          id: uid(),
          onStateUpdate: onStateUpdate
        };
        query.instances.push(instance);
        query.heal();

        instance.clearInterval = function () {
          clearInterval(instance.refetchIntervalId);
          delete instance.refetchIntervalId;
        };

        instance.updateConfig = function (config) {
          var oldConfig = instance.config; // Update the config

          instance.config = config;

          if (!isServer) {
            if ((oldConfig == null ? void 0 : oldConfig.refetchInterval) === config.refetchInterval) {
              return;
            }

            query.clearIntervals();
            var minInterval = Math.min.apply(Math, query.instances.map(function (d) {
              return d.config.refetchInterval || Infinity;
            }));

            if (!instance.refetchIntervalId && minInterval > 0 && minInterval < Infinity) {
              instance.refetchIntervalId = setInterval(function () {
                if (isDocumentVisible() || query.instances.some(function (instance) {
                  return instance.config.refetchIntervalInBackground;
                })) {
                  query.fetch();
                }
              }, minInterval);
            }
          }
        };

        instance.run = _async(function () {
          return _continueIgnored(_catch(function () {
            // Perform the refetch for this query if necessary
            return _invoke(function () {
              if (query.config.enabled && // Don't auto refetch if disabled
              !query.wasSuspended && // Don't double refetch for suspense
              query.state.isStale && ( // Only refetch if stale
              query.config.refetchOnMount || query.instances.length === 1)) {
                return _awaitIgnored(query.fetch());
              }
            }, function () {
              query.wasSuspended = false;
            });
          }, function (error) {
            Console.error(error);
          }));
        });

        instance.unsubscribe = function () {
          query.instances = query.instances.filter(function (d) {
            return d.id !== instance.id;
          });

          if (!query.instances.length) {
            query.clearIntervals();
            query.cancel();

            if (!isServer) {
              // Schedule garbage collection
              query.scheduleGarbageCollection();
            }
          }
        };

        return instance;
      }; // Set up the core fetcher function


      var tryFetchData = _async(function (queryFn) {
        for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          args[_key2 - 1] = arguments[_key2];
        }

        return _catch(function () {
          // Perform the query
          var promise = queryFn.apply(void 0, query.config.queryFnParamsFilter(args));

          query.cancelPromises = function () {
            return promise.cancel == null ? void 0 : promise.cancel();
          };

          return _await(promise, function (data) {
            delete query.shouldContinueRetryOnFocus;
            delete query.cancelPromises;
            if (query.cancelled) throw query.cancelled;
            return data;
          });
        }, function (error) {
          var _exit = false;
          delete query.cancelPromises;
          if (query.cancelled) throw query.cancelled; // If we fail, increase the failureCount

          query.dispatch({
            type: actionFailed
          }); // Do we need to retry the request?

          return _invoke(function () {
            if (query.config.retry === true || query.state.failureCount <= query.config.retry || typeof query.config.retry === 'function' && query.config.retry(query.state.failureCount, error)) {
              // Only retry if the document is visible
              if (!isDocumentVisible()) {
                // set this flag to continue retries on focus
                query.shouldContinueRetryOnFocus = true;
                _exit = true;
                return new Promise(noop);
              }

              delete query.shouldContinueRetryOnFocus; // Determine the retryDelay

              var delay = functionalUpdate(query.config.retryDelay, query.state.failureCount); // Return a new promise with the retry

              _exit = true;
              return _await(new Promise(function (resolve, reject) {
                // Keep track of the retry timeout
                query.retryTimeout = setTimeout(_async(function () {
                  return query.cancelled ? reject(query.cancelled) : _catch(function () {
                    return _await(tryFetchData.apply(void 0, [queryFn].concat(args)), function (data) {
                      if (query.cancelled) return reject(query.cancelled);
                      resolve(data);
                    });
                  }, function (error) {
                    if (query.cancelled) return reject(query.cancelled);
                    reject(error);
                  });
                }), delay);
              }));
            }
          }, function (_result3) {
            if (_exit) return _result3;
            throw error;
          });
        });
      });

      query.fetch = _async(function (_temp5) {
        var _ref7 = _temp5 === void 0 ? {} : _temp5,
            _ref7$__queryFn = _ref7.__queryFn,
            __queryFn = _ref7$__queryFn === void 0 ? query.queryFn : _ref7$__queryFn;

        // Create a new promise for the query cache if necessary
        if (!query.promise) {
          query.promise = _async(function () {
            // If there are any retries pending for this query, kill them
            query.cancelled = null;
            var callbackInstances = [].concat(query.instances);

            if (query.wasSuspended) {
              callbackInstances.unshift(query.fallbackInstance);
            }

            return _catch(function () {
              // Set up the query refreshing state
              query.dispatch({
                type: actionFetch
              }); // Try to get the data

              return _await(tryFetchData.apply(void 0, [__queryFn].concat(query.queryKey)), function (data) {
                query.setData(function (old) {
                  return query.config.isDataEqual(old, data) ? old : data;
                });
                callbackInstances.forEach(function (instance) {
                  return instance.config.onSuccess && instance.config.onSuccess(query.state.data);
                });
                callbackInstances.forEach(function (instance) {
                  return instance.config.onSettled && instance.config.onSettled(query.state.data, null);
                });
                delete query.promise;
                return data;
              });
            }, function (error) {
              query.dispatch({
                type: actionError,
                cancelled: error === query.cancelled,
                error: error
              });
              delete query.promise;

              if (error !== query.cancelled) {
                callbackInstances.forEach(function (instance) {
                  return instance.config.onError && instance.config.onError(error);
                });
                callbackInstances.forEach(function (instance) {
                  return instance.config.onSettled && instance.config.onSettled(undefined, error);
                });
                throw error;
              }
            });
          })();
        }

        return query.promise;
      });
      return query;
    }

    return queryCache;
  }
  function queryReducer(state, action) {
    var newState = switchActions(state, action);
    Object.assign(newState, {
      isLoading: newState.status === statusLoading,
      isSuccess: newState.status === statusSuccess,
      isError: newState.status === statusError,
      isIdle: newState.status === statusIdle
    });
    return newState;
  }

  function switchActions(state, action) {
    switch (action.type) {
      case actionInit:
        return {
          status: action.initialStatus,
          error: null,
          isFetching: action.initialStatus === 'loading',
          canFetchMore: false,
          failureCount: 0,
          isStale: action.isStale,
          markedForGarbageCollection: false,
          data: action.initialData,
          updatedAt: action.hasInitialData ? Date.now() : 0
        };

      case actionFailed:
        return _extends({}, state, {
          failureCount: state.failureCount + 1
        });

      case actionMarkStale:
        return _extends({}, state, {
          isStale: true
        });

      case actionMarkGC:
        {
          return _extends({}, state, {
            markedForGarbageCollection: true
          });
        }

      case actionFetch:
        return _extends({}, state, {
          status: typeof state.data !== 'undefined' ? statusSuccess : statusLoading,
          isFetching: true,
          failureCount: 0
        });

      case actionSuccess:
        return _extends({}, state, {
          status: statusSuccess,
          data: functionalUpdate(action.updater, state.data),
          error: null,
          isStale: false,
          isFetching: false,
          canFetchMore: action.canFetchMore,
          updatedAt: Date.now(),
          failureCount: 0
        });

      case actionError:
        return _extends({}, state, {
          isFetching: false,
          isStale: true
        }, !action.cancelled && {
          status: statusError,
          error: action.error,
          throwInErrorBoundary: true
        });

      case actionSetState:
        return functionalUpdate(action.updater, state);

      default:
        throw new Error();
    }
  }

  var visibilityChangeEvent = 'visibilitychange';
  var focusEvent = 'focus';

  var onWindowFocus = function onWindowFocus() {
    if (isDocumentVisible() && isOnline()) {
      queryCaches.forEach(function (queryCache) {
        return queryCache.invalidateQueries(function (query) {
          if (!query.instances.length) {
            return false;
          }

          if (!query.instances.some(function (instance) {
            return instance.config.enabled;
          })) {
            return false;
          }

          if (!query.state.isStale) {
            return false;
          }

          if (query.shouldContinueRetryOnFocus) {
            // delete promise, so refetching will create new one
            delete query.promise;
          }

          return query.config.refetchOnWindowFocus;
        }).catch(Console.error);
      });
    }
  };

  var removePreviousHandler;
  function setFocusHandler(callback) {
    // Unsub the old watcher
    if (removePreviousHandler) {
      removePreviousHandler();
    } // Sub the new watcher


    removePreviousHandler = callback(onWindowFocus);
  }
  setFocusHandler(function (handleFocus) {
    var _window;

    // Listen to visibillitychange and focus
    if (!isServer && ((_window = window) == null ? void 0 : _window.addEventListener)) {
      window.addEventListener(visibilityChangeEvent, handleFocus, false);
      window.addEventListener(focusEvent, handleFocus, false);
      return function () {
        // Be sure to unsubscribe if a new handler is set
        window.removeEventListener(visibilityChangeEvent, handleFocus);
        window.removeEventListener(focusEvent, handleFocus);
      };
    }
  });

  function useIsFetching() {
    var queryCache = useQueryCache();

    var _React$useReducer = React.useReducer(function (d) {
      return d + 1;
    }, 1),
        state = _React$useReducer[0],
        unsafeRerender = _React$useReducer[1];

    var rerender = useMountedCallback(unsafeRerender);
    React.useEffect(function () {
      return queryCache.subscribe(rerender);
    }, [queryCache, rerender]);
    return React.useMemo(function () {
      return state && queryCache.isFetching;
    }, [queryCache.isFetching, state]);
  }

  function _await$1(value, then, direct) {
    if (direct) {
      return then ? then(value) : value;
    }

    if (!value || !value.then) {
      value = Promise.resolve(value);
    }

    return then ? value.then(then) : value;
  }

  var getDefaultState = function getDefaultState() {
    return {
      status: statusIdle,
      data: undefined,
      error: null
    };
  };

  function _empty$1() {}

  var actionReset = {};

  function _awaitIgnored$1(value, direct) {
    if (!direct) {
      return value && value.then ? value.then(_empty$1) : Promise.resolve();
    }
  }

  var actionLoading = {};

  function _invoke$1(body, then) {
    var result = body();

    if (result && result.then) {
      return result.then(then);
    }

    return then(result);
  }

  var actionResolve = {};

  function _catch$1(body, recover) {
    try {
      var result = body();
    } catch (e) {
      return recover(e);
    }

    if (result && result.then) {
      return result.then(void 0, recover);
    }

    return result;
  }

  var actionReject = {};

  function _async$1(f) {
    return function () {
      for (var args = [], i = 0; i < arguments.length; i++) {
        args[i] = arguments[i];
      }

      try {
        return Promise.resolve(f.apply(this, args));
      } catch (e) {
        return Promise.reject(e);
      }
    };
  }

  function mutationReducer(state, action) {
    if (action.type === actionReset) {
      return getDefaultState();
    }

    if (action.type === actionLoading) {
      return {
        status: statusLoading
      };
    }

    if (action.type === actionResolve) {
      return {
        status: statusSuccess,
        data: action.data
      };
    }

    if (action.type === actionReject) {
      return {
        status: statusError,
        error: action.error
      };
    }

    throw new Error();
  }

  function useMutation(mutationFn, config) {
    if (config === void 0) {
      config = {};
    }

    var _React$useReducer = React.useReducer(mutationReducer, null, getDefaultState),
        state = _React$useReducer[0],
        unsafeDispatch = _React$useReducer[1];

    var dispatch = useMountedCallback(unsafeDispatch);
    var getMutationFn = useGetLatest(mutationFn);
    var getConfig = useGetLatest(_extends({}, useConfigContext().shared, useConfigContext().mutations, config));
    var latestMutationRef = React.useRef();
    var mutate = React.useCallback(_async$1(function (variables, _temp) {
      var _ref = _temp === void 0 ? {} : _temp,
          _ref$onSuccess = _ref.onSuccess,
          onSuccess = _ref$onSuccess === void 0 ? noop : _ref$onSuccess,
          _ref$onError = _ref.onError,
          onError = _ref$onError === void 0 ? noop : _ref$onError,
          _ref$onSettled = _ref.onSettled,
          onSettled = _ref$onSettled === void 0 ? noop : _ref$onSettled,
          throwOnError = _ref.throwOnError;

      var config = getConfig();
      var mutationId = uid();
      latestMutationRef.current = mutationId;

      var isLatest = function isLatest() {
        return latestMutationRef.current === mutationId;
      };

      dispatch({
        type: actionLoading
      });
      var snapshotValue;
      return _catch$1(function () {
        return _await$1(config.onMutate(variables), function (_config$onMutate) {
          snapshotValue = _config$onMutate;
          var data;
          return _invoke$1(function () {
            if (isLatest()) {
              return _await$1(getMutationFn()(variables), function (_getMutationFn) {
                data = _getMutationFn;
              });
            }
          }, function () {
            if (isLatest()) {
              dispatch({
                type: actionResolve,
                data: data
              });
            }

            return _invoke$1(function () {
              if (isLatest()) {
                return _awaitIgnored$1(config.onSuccess(data, variables));
              }
            }, function () {
              return _invoke$1(function () {
                if (isLatest()) {
                  return _awaitIgnored$1(onSuccess(data, variables));
                }
              }, function () {
                return _invoke$1(function () {
                  if (isLatest()) {
                    return _awaitIgnored$1(config.onSettled(data, null, variables));
                  }
                }, function () {
                  return _invoke$1(function () {
                    if (isLatest()) {
                      return _awaitIgnored$1(onSettled(data, null, variables));
                    }
                  }, function () {
                    return data;
                  });
                });
              });
            });
          });
        });
      }, function (error) {
        return _invoke$1(function () {
          if (isLatest()) {
            Console.error(error);
            return _awaitIgnored$1(config.onError(error, variables, snapshotValue));
          }
        }, function () {
          return _invoke$1(function () {
            if (isLatest()) {
              return _awaitIgnored$1(onError(error, variables, snapshotValue));
            }
          }, function () {
            return _invoke$1(function () {
              if (isLatest()) {
                return _awaitIgnored$1(config.onSettled(undefined, error, variables, snapshotValue));
              }
            }, function () {
              return _invoke$1(function () {
                if (isLatest()) {
                  return _awaitIgnored$1(onSettled(undefined, error, variables, snapshotValue));
                }
              }, function () {
                if (isLatest()) {
                  dispatch({
                    type: actionReject,
                    error: error
                  });

                  if (throwOnError != null ? throwOnError : config.throwOnError) {
                    throw error;
                  }
                }
              });
            });
          });
        });
      });
    }), [dispatch, getConfig, getMutationFn]);
    var reset = React.useCallback(function () {
      return dispatch({
        type: actionReset
      });
    }, [dispatch]);
    React.useEffect(function () {
      var _getConfig = getConfig(),
          suspense = _getConfig.suspense,
          useErrorBoundary = _getConfig.useErrorBoundary;

      if ((useErrorBoundary != null ? useErrorBoundary : suspense) && state.error) {
        throw state.error;
      }
    }, [getConfig, state.error]);
    return [mutate, _extends({}, state, {
      reset: reset,
      isIdle: state.status === statusIdle,
      isLoading: state.status === statusLoading,
      isSuccess: state.status === statusSuccess,
      isError: state.status === statusError
    })];
  }

  function _empty$2() {}

  function _awaitIgnored$2(value, direct) {
    if (!direct) {
      return value && value.then ? value.then(_empty$2) : Promise.resolve();
    }
  }

  function _catch$2(body, recover) {
    try {
      var result = body();
    } catch (e) {
      return recover(e);
    }

    if (result && result.then) {
      return result.then(void 0, recover);
    }

    return result;
  }

  function _continueIgnored$1(value) {
    if (value && value.then) {
      return value.then(_empty$2);
    }
  }

  function _async$2(f) {
    return function () {
      for (var args = [], i = 0; i < arguments.length; i++) {
        args[i] = arguments[i];
      }

      try {
        return Promise.resolve(f.apply(this, args));
      } catch (e) {
        return Promise.reject(e);
      }
    };
  }

  function useBaseQuery(queryKey, queryFn, config) {
    if (config === void 0) {
      config = {};
    }

    // Make a rerender function
    var rerender = useMountedCallback(React.useState()[1]); // Build the final config

    var configContext = useConfigContext();
    config = _extends({}, configContext.shared, configContext.queries, config); // Get the query cache

    var queryCache = useQueryCache(); // Build the query for use

    var query = queryCache.buildQuery(queryKey, queryFn, config); // Create a query instance ref

    var instanceRef = React.useRef(); // Subscribe to the query when the subscribe function changes

    React.useEffect(function () {
      instanceRef.current = query.subscribe(function () {
        return rerender({});
      }); // Unsubscribe when things change

      return instanceRef.current.unsubscribe;
    }, [query, rerender]); // Always update the config

    React.useEffect(function () {
      instanceRef.current.updateConfig(config);
    }); // Run the instance when the query or enabled change

    React.useEffect(function () {
      if (config.enabled && query) ;

      instanceRef.current.run();
    }, [config.enabled, query]);
    var refetch = React.useCallback(_async$2(function () {
      return _continueIgnored$1(_catch$2(function () {
        return _awaitIgnored$2(query.fetch());
      }, function (error) {
        Console.error(error);
      }));
    }), [query]);
    return _extends({
      query: query,
      refetch: refetch
    }, query.state);
  }

  function useQuery() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var query = useBaseQuery.apply(void 0, getQueryArgs(args));
    handleSuspense(query);
    return query;
  }

  function usePaginatedQuery() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _getQueryArgs = getQueryArgs(args),
        queryKey = _getQueryArgs[0],
        queryFn = _getQueryArgs[1],
        _getQueryArgs$ = _getQueryArgs[2],
        config = _getQueryArgs$ === void 0 ? {} : _getQueryArgs$;

    var lastDataRef = React.useRef(); // If latestData is set, don't use initialData

    if (typeof lastDataRef.current !== 'undefined') {
      delete config.initialData;
    }

    var queryInfo = useBaseQuery(queryKey, queryFn, config);

    if (!queryInfo.query.config.enabled) {
      lastDataRef.current = undefined;
    }

    var latestData = queryInfo.data,
        status = queryInfo.status;
    React.useEffect(function () {
      if (status === 'success' && typeof latestData !== 'undefined') {
        lastDataRef.current = latestData;
      }
    }, [latestData, status]);
    var resolvedData = latestData;

    if (typeof resolvedData === 'undefined') {
      resolvedData = lastDataRef.current;
    }

    if (typeof resolvedData !== 'undefined') {
      var overrides = {
        status: 'success',
        isError: false,
        isLoading: false,
        isSuccess: true
      };
      Object.assign(queryInfo.query.state, overrides);
      Object.assign(queryInfo, overrides);
    }

    var paginatedQueryInfo = _extends({}, queryInfo, {
      resolvedData: resolvedData,
      latestData: latestData
    });

    handleSuspense(paginatedQueryInfo);
    return paginatedQueryInfo;
  }

  function _await$2(value, then, direct) {
    if (direct) {
      return then ? then(value) : value;
    }

    if (!value || !value.then) {
      value = Promise.resolve(value);
    }

    return then ? value.then(then) : value;
  }

  function _empty$3() {}

  function _invokeIgnored(body) {
    var result = body();

    if (result && result.then) {
      return result.then(_empty$3);
    }
  }

  function _settle(pact, state, value) {
    if (!pact.s) {
      if (value instanceof _Pact) {
        if (value.s) {
          if (state & 1) {
            state = value.s;
          }

          value = value.v;
        } else {
          value.o = _settle.bind(null, pact, state);
          return;
        }
      }

      if (value && value.then) {
        value.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));
        return;
      }

      pact.s = state;
      pact.v = value;
      var observer = pact.o;

      if (observer) {
        observer(pact);
      }
    }
  }

  var _Pact = /*#__PURE__*/function () {
    function _Pact() {}

    _Pact.prototype.then = function (onFulfilled, onRejected) {
      var result = new _Pact();
      var state = this.s;

      if (state) {
        var callback = state & 1 ? onFulfilled : onRejected;

        if (callback) {
          try {
            _settle(result, 1, callback(this.v));
          } catch (e) {
            _settle(result, 2, e);
          }

          return result;
        } else {
          return this;
        }
      }

      this.o = function (_this) {
        try {
          var value = _this.v;

          if (_this.s & 1) {
            _settle(result, 1, onFulfilled ? onFulfilled(value) : value);
          } else if (onRejected) {
            _settle(result, 1, onRejected(value));
          } else {
            _settle(result, 2, value);
          }
        } catch (e) {
          _settle(result, 2, e);
        }
      };

      return result;
    };

    return _Pact;
  }();

  function _isSettledPact(thenable) {
    return thenable instanceof _Pact && thenable.s & 1;
  }

  function _do(body, test) {
    var awaitBody;

    do {
      var result = body();

      if (result && result.then) {
        if (_isSettledPact(result)) {
          result = result.v;
        } else {
          awaitBody = true;
          break;
        }
      }

      var shouldContinue = test();

      if (_isSettledPact(shouldContinue)) {
        shouldContinue = shouldContinue.v;
      }

      if (!shouldContinue) {
        return result;
      }
    } while (!shouldContinue.then);

    var pact = new _Pact();

    var reject = _settle.bind(null, pact, 2);

    (awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);
    return pact;

    function _resumeAfterBody(value) {
      result = value;

      for (;;) {
        shouldContinue = test();

        if (_isSettledPact(shouldContinue)) {
          shouldContinue = shouldContinue.v;
        }

        if (!shouldContinue) {
          break;
        }

        if (shouldContinue.then) {
          shouldContinue.then(_resumeAfterTest).then(void 0, reject);
          return;
        }

        result = body();

        if (result && result.then) {
          if (_isSettledPact(result)) {
            result = result.v;
          } else {
            result.then(_resumeAfterBody).then(void 0, reject);
            return;
          }
        }
      }

      _settle(pact, 1, result);
    }

    function _resumeAfterTest(shouldContinue) {
      if (shouldContinue) {
        do {
          result = body();

          if (result && result.then) {
            if (_isSettledPact(result)) {
              result = result.v;
            } else {
              result.then(_resumeAfterBody).then(void 0, reject);
              return;
            }
          }

          shouldContinue = test();

          if (_isSettledPact(shouldContinue)) {
            shouldContinue = shouldContinue.v;
          }

          if (!shouldContinue) {
            _settle(pact, 1, result);

            return;
          }
        } while (!shouldContinue.then);

        shouldContinue.then(_resumeAfterTest).then(void 0, reject);
      } else {
        _settle(pact, 1, result);
      }
    }
  }

  function _continue(value, then) {
    return value && value.then ? value.then(then) : then(value);
  }

  function _async$3(f) {
    return function () {
      for (var args = [], i = 0; i < arguments.length; i++) {
        args[i] = arguments[i];
      }

      try {
        return Promise.resolve(f.apply(this, args));
      } catch (e) {
        return Promise.reject(e);
      }
    };
  }

  function _rethrow(thrown, value) {
    if (thrown) throw value;
    return value;
  }

  function _finallyRethrows(body, finalizer) {
    try {
      var result = body();
    } catch (e) {
      return finalizer(true, e);
    }

    if (result && result.then) {
      return result.then(finalizer.bind(null, false), finalizer.bind(null, true));
    }

    return finalizer(false, result);
  }

  function useInfiniteQuery() {
    var queryInfoRef = React.useRef();

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _getQueryArgs = getQueryArgs(args),
        queryKey = _getQueryArgs[0],
        queryFn = _getQueryArgs[1],
        _getQueryArgs$ = _getQueryArgs[2],
        config = _getQueryArgs$ === void 0 ? {} : _getQueryArgs$;

    var getFetchMore = config.getFetchMore;
    var getGetFetchMore = useGetLatest(getFetchMore); // The default queryFn will query all pages and map them together

    var originalQueryFn = queryFn;
    queryFn = _async$3(function () {
      var _interrupt = false;
      var data = [];
      var pageVariables = [].concat(queryInfoRef.current.query.pageVariables);
      var rebuiltPageVariables = [];
      return _continue(_do(function () {
        var args = pageVariables.shift();
        return _invokeIgnored(function () {
          if (!data.length) {
            var _push3 = data.push;
            // the first page query doesn't need to be rebuilt
            return _await$2(originalQueryFn.apply(void 0, args), function (_originalQueryFn) {
              _push3.call(data, _originalQueryFn);

              rebuiltPageVariables.push(args);
            });
          } else {
            // get an up-to-date cursor based on the previous data set
            var nextCursor = getGetFetchMore()(data[data.length - 1], data); // break early if there's no next cursor
            // otherwise we'll start from the beginning
            // which will cause unwanted duplication

            if (!nextCursor) {
              _interrupt = true;
              return;
            }

            var pageArgs = [].concat(args.slice(0, -1), [nextCursor]);
            var _push4 = data.push;
            return _await$2(originalQueryFn.apply(void 0, pageArgs), function (_originalQueryFn2) {
              _push4.call(data, _originalQueryFn2);

              rebuiltPageVariables.push(pageArgs);
            });
          }
        });
      }, function () {
        return !_interrupt && !!pageVariables.length;
      }), function () {
        queryInfoRef.current.query.canFetchMore = getGetFetchMore()(data[data.length - 1], data);
        queryInfoRef.current.query.pageVariables = rebuiltPageVariables;
        return data;
      });
    });
    var queryInfo = useBaseQuery(queryKey, queryFn, config);

    if (typeof queryInfo.query.canFetchMore === 'undefined' && typeof queryInfo.data !== 'undefined') {
      queryInfo.query.canFetchMore = getGetFetchMore()(queryInfo.data[queryInfo.data.length - 1], queryInfo.data);
    }

    queryInfoRef.current = queryInfo;
    var _queryInfo$data = queryInfo.data,
        data = _queryInfo$data === void 0 ? [] : _queryInfo$data,
        canFetchMore = queryInfo.query.canFetchMore; // Here we seed the pageVariabes for the query

    if (!queryInfo.query.pageVariables) {
      queryInfo.query.pageVariables = [[].concat(queryInfo.query.queryKey)];
    }

    var fetchMore = React.useCallback(function (fetchMoreInfo, _temp) {
      if (fetchMoreInfo === void 0) {
        fetchMoreInfo = queryInfoRef.current.query.canFetchMore;
      }

      var _ref = _temp === void 0 ? {} : _temp,
          _ref$previous = _ref.previous,
          previous = _ref$previous === void 0 ? false : _ref$previous;

      return queryInfoRef.current.query.canFetchMore ? queryInfoRef.current.query.fetch({
        __queryFn: _async$3(function () {
          for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
          }

          return _finallyRethrows(function () {
            queryInfoRef.current.query.setState(function (old) {
              return _extends({}, old, {
                isFetchingMore: previous ? 'previous' : 'next'
              });
            });
            var newArgs = previous ? [fetchMoreInfo].concat(args) : [].concat(args, [fetchMoreInfo]);
            queryInfoRef.current.query.pageVariables[previous ? 'unshift' : 'push'](newArgs);
            return _await$2(originalQueryFn.apply(void 0, newArgs), function (newData) {
              var data = previous ? [newData].concat(queryInfoRef.current.data) : [].concat(queryInfoRef.current.data, [newData]);
              queryInfoRef.current.query.canFetchMore = getGetFetchMore()(newData, data);
              return data;
            });
          }, function (_wasThrown, _result) {
            queryInfoRef.current.query.setState(function (old) {
              return _extends({}, old, {
                isFetchingMore: false
              });
            });
            return _rethrow(_wasThrown, _result);
          });
        })
      }) : void 0;
    }, [getGetFetchMore, originalQueryFn]);
    handleSuspense(queryInfo);
    return _extends({}, queryInfo, {
      data: data,
      canFetchMore: canFetchMore,
      fetchMore: fetchMore
    });
  }

  exports.ReactQueryCacheProvider = ReactQueryCacheProvider;
  exports.ReactQueryConfigProvider = ReactQueryConfigProvider;
  exports.deepIncludes = deepIncludes;
  exports.makeQueryCache = makeQueryCache;
  exports.queryCache = queryCache;
  exports.queryCaches = queryCaches;
  exports.setConsole = setConsole;
  exports.setFocusHandler = setFocusHandler;
  exports.stableStringify = stableStringify;
  exports.statusError = statusError;
  exports.statusIdle = statusIdle;
  exports.statusLoading = statusLoading;
  exports.statusSuccess = statusSuccess;
  exports.useInfiniteQuery = useInfiniteQuery;
  exports.useIsFetching = useIsFetching;
  exports.useMutation = useMutation;
  exports.usePaginatedQuery = usePaginatedQuery;
  exports.useQuery = useQuery;
  exports.useQueryCache = useQueryCache;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=react-query.development.js.map
