{"version":3,"file":"react-query.production.min.js","sources":["../src/utils.js","../src/config.js","../src/queryCache.js","../src/setFocusHandler.js","../src/useMutation.js","../src/useBaseQuery.js","../src/useInfiniteQuery.js","../src/useIsFetching.js","../src/usePaginatedQuery.js","../src/useQuery.js"],"sourcesContent":["import React from 'react'\n\n//\n\nexport const statusIdle = 'idle'\nexport const statusLoading = 'loading'\nexport const statusError = 'error'\nexport const statusSuccess = 'success'\n\nlet _uid = 0\nexport const uid = () => _uid++\nexport const cancelledError = {}\nexport let globalStateListeners = []\nexport const isServer = typeof window === 'undefined'\nexport const noop = () => {}\nexport const identity = d => d\nexport let Console = console || { error: noop, warn: noop, log: noop }\n\nexport function useUid() {\n  const ref = React.useRef(null)\n\n  if (ref.current === null) {\n    ref.current = uid()\n  }\n\n  return ref.current\n}\n\nexport function setConsole(c) {\n  Console = c\n}\n\nexport function useGetLatest(obj) {\n  const ref = React.useRef()\n  ref.current = obj\n\n  return React.useCallback(() => ref.current, [])\n}\n\nexport function functionalUpdate(updater, old) {\n  return typeof updater === 'function' ? updater(old) : updater\n}\n\nexport function stableStringifyReplacer(_, value) {\n  return isObject(value)\n    ? Object.assign(\n        {},\n        ...Object.keys(value)\n          .sort()\n          .map(key => ({\n            [key]: value[key],\n          }))\n      )\n    : value\n}\n\nexport function stableStringify(obj) {\n  return JSON.stringify(obj, stableStringifyReplacer)\n}\n\nexport function isObject(a) {\n  return a && typeof a === 'object' && !Array.isArray(a)\n}\n\nexport function deepIncludes(a, b) {\n  if (a === b) {\n    return true\n  }\n\n  if (typeof a !== typeof b) {\n    return false\n  }\n\n  if (typeof a === 'object') {\n    return !Object.keys(b).some(key => !deepIncludes(a[key], b[key]))\n  }\n\n  return false\n}\n\nexport function isDocumentVisible() {\n  return (\n    typeof document === 'undefined' ||\n    document.visibilityState === undefined ||\n    document.visibilityState === 'visible' ||\n    document.visibilityState === 'prerender'\n  )\n}\n\nexport function isOnline() {\n  return navigator.onLine === undefined || navigator.onLine\n}\n\nexport function getQueryArgs(args) {\n  if (isObject(args[0])) {\n    if (\n      args[0].hasOwnProperty('queryKey') &&\n      args[0].hasOwnProperty('queryFn')\n    ) {\n      const { queryKey, queryFn, config = {} } = args[0]\n      return [queryKey, queryFn, config, ...args.slice(1)]\n    } else {\n      throw new Error('queryKey and queryFn keys are required.')\n    }\n  }\n\n  const [queryKey, queryFn, config = {}, ...rest] = args\n\n  return [queryKey, queryFn, config, ...rest]\n}\n\nexport function useMountedCallback(callback) {\n  const mounted = React.useRef(false)\n\n  React[isServer ? 'useEffect' : 'useLayoutEffect'](() => {\n    mounted.current = true\n    return () => (mounted.current = false)\n  }, [])\n\n  return React.useCallback(\n    (...args) => (mounted.current ? callback(...args) : void 0),\n    [callback]\n  )\n}\n\nexport function handleSuspense(queryInfo) {\n  if (\n    queryInfo.query.config.suspense ||\n    queryInfo.query.config.useErrorBoundary\n  ) {\n    if (\n      queryInfo.query.state.status === statusError &&\n      queryInfo.query.state.throwInErrorBoundary\n    ) {\n      throw queryInfo.error\n    }\n\n    if (queryInfo.query.config.suspense && queryInfo.status !== statusSuccess) {\n      queryInfo.query.wasSuspended = true\n      throw queryInfo.query.fetch()\n    }\n  }\n}\n\n// This deep-equal is directly based on https://github.com/epoberezkin/fast-deep-equal.\n// The parts for comparing any non-JSON-supported values has been removed\nexport function deepEqual(a, b) {\n  if (a === b) return true\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    var length, i, keys\n    if (Array.isArray(a)) {\n      length = a.length\n      // eslint-disable-next-line eqeqeq\n      if (length != b.length) return false\n      for (i = length; i-- !== 0; ) if (!deepEqual(a[i], b[i])) return false\n      return true\n    }\n\n    if (a.valueOf !== Object.prototype.valueOf)\n      return a.valueOf() === b.valueOf()\n\n    keys = Object.keys(a)\n    length = keys.length\n    if (length !== Object.keys(b).length) return false\n\n    for (i = length; i-- !== 0; )\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false\n\n    for (i = length; i-- !== 0; ) {\n      var key = keys[i]\n\n      if (!deepEqual(a[key], b[key])) return false\n    }\n\n    return true\n  }\n\n  // true if both NaN, false otherwise\n  // eslint-disable-next-line no-self-compare\n  return a !== a && b !== b\n}\n","import React from 'react'\nimport { noop, stableStringify, identity, deepEqual } from './utils'\n\nexport const configContext = React.createContext()\n\nconst DEFAULTS = {\n  shared: {\n    suspense: false,\n    queryKeySerializerFn: defaultQueryKeySerializerFn,\n  },\n  queries: {\n    enabled: true,\n    retry: 3,\n    retryDelay: attemptIndex => Math.min(1000 * 2 ** attemptIndex, 30000),\n    staleTime: 0,\n    cacheTime: 5 * 60 * 1000,\n    refetchOnWindowFocus: true,\n    refetchInterval: false,\n    queryFnParamsFilter: identity,\n    refetchOnMount: true,\n    isDataEqual: deepEqual,\n    onError: noop,\n    onSuccess: noop,\n    onSettled: noop,\n    useErrorBoundary: false,\n  },\n  mutations: {\n    throwOnError: false,\n    onMutate: noop,\n    onError: noop,\n    onSuccess: noop,\n    onSettled: noop,\n    useErrorBoundary: false,\n  },\n}\n\nexport const defaultConfigRef = {\n  current: DEFAULTS,\n}\n\nexport function useConfigContext() {\n  return React.useContext(configContext) || defaultConfigRef.current\n}\n\nexport function ReactQueryConfigProvider({ config, children }) {\n  let configContextValue = useConfigContext()\n\n  const newConfig = React.useMemo(() => {\n    const { shared = {}, queries = {}, mutations = {} } = config\n    const {\n      shared: contextShared = {},\n      queries: contextQueries = {},\n      mutations: contextMutations = {},\n    } = configContextValue\n    return {\n      shared: {\n        ...contextShared,\n        ...shared,\n      },\n      queries: {\n        ...contextQueries,\n        ...queries,\n      },\n      mutations: {\n        ...contextMutations,\n        ...mutations,\n      },\n    }\n  }, [config, configContextValue])\n\n  React.useEffect(() => {\n    // restore previous config on unmount\n    return () => {\n      defaultConfigRef.current = { ...(configContextValue || DEFAULTS) }\n    }\n  }, [configContextValue])\n\n  if (!configContextValue) {\n    defaultConfigRef.current = newConfig\n  }\n\n  return (\n    <configContext.Provider value={newConfig}>\n      {children}\n    </configContext.Provider>\n  )\n}\n\nfunction invalidQueryKey() {\n  throw new Error('A valid query key is required!')\n}\n\nexport function defaultQueryKeySerializerFn(queryKey) {\n  if (!queryKey) {\n    invalidQueryKey()\n  }\n\n  if (!Array.isArray(queryKey)) {\n    queryKey = [queryKey]\n  }\n\n  if (queryKey.some(d => typeof d === 'function')) {\n    invalidQueryKey()\n  }\n\n  const queryHash = stableStringify(queryKey)\n  queryKey = JSON.parse(queryHash)\n\n  if (!queryHash) {\n    invalidQueryKey()\n  }\n\n  return [queryHash, queryKey]\n}\n","import React from 'react'\nimport {\n  isServer,\n  functionalUpdate,\n  cancelledError,\n  isDocumentVisible,\n  statusLoading,\n  statusSuccess,\n  statusError,\n  getQueryArgs,\n  deepIncludes,\n  noop,\n  uid,\n  statusIdle,\n  Console,\n} from './utils'\nimport { defaultConfigRef } from './config'\n\nexport const queryCache = makeQueryCache()\n\nexport const queryCacheContext = React.createContext(queryCache)\n\nexport const queryCaches = [queryCache]\n\nexport const useQueryCache = () => React.useContext(queryCacheContext)\n\nexport function ReactQueryCacheProvider({ queryCache, children }) {\n  const resolvedQueryCache = React.useMemo(\n    () => queryCache || makeQueryCache(),\n    [queryCache]\n  )\n\n  React.useEffect(() => {\n    queryCaches.push(resolvedQueryCache)\n\n    return () => {\n      // remove the cache from the active list\n      const i = queryCaches.indexOf(resolvedQueryCache)\n      if (i > -1) {\n        queryCaches.splice(i, 1)\n      }\n      // if the resolvedQueryCache was created by us, we need to tear it down\n      if (queryCache == null) {\n        resolvedQueryCache.clear()\n      }\n    }\n  }, [resolvedQueryCache, queryCache])\n\n  return (\n    <queryCacheContext.Provider value={resolvedQueryCache}>\n      {children}\n    </queryCacheContext.Provider>\n  )\n}\n\nconst actionInit = 'Init'\nconst actionFailed = 'Failed'\nconst actionMarkStale = 'MarkStale'\nconst actionMarkGC = 'MarkGC'\nconst actionFetch = 'Fetch'\nconst actionSuccess = 'Success'\nconst actionError = 'Error'\nconst actionSetState = 'SetState'\n\nexport function makeQueryCache({ frozen = isServer, defaultConfig } = {}) {\n  // A frozen cache does not add new queries to the cache\n  const globalListeners = []\n\n  const configRef = defaultConfig\n    ? { current: defaultConfig }\n    : defaultConfigRef\n\n  const queryCache = {\n    queries: {},\n    isFetching: 0,\n  }\n\n  const notifyGlobalListeners = () => {\n    queryCache.isFetching = Object.values(queryCache.queries).reduce(\n      (acc, query) => (query.state.isFetching ? acc + 1 : acc),\n      0\n    )\n\n    globalListeners.forEach(d => d(queryCache))\n  }\n\n  queryCache.subscribe = cb => {\n    globalListeners.push(cb)\n    return () => {\n      globalListeners.splice(globalListeners.indexOf(cb), 1)\n    }\n  }\n\n  queryCache.clear = ({ notify = true } = {}) => {\n    Object.values(queryCache.queries).forEach(query => query.clear())\n    queryCache.queries = {}\n    if (notify) {\n      notifyGlobalListeners()\n    }\n  }\n\n  queryCache.getQueries = (predicate, { exact } = {}) => {\n    if (predicate === true) {\n      return Object.values(queryCache.queries)\n    }\n\n    if (typeof predicate !== 'function') {\n      const [\n        queryHash,\n        queryKey,\n      ] = configRef.current.shared.queryKeySerializerFn(predicate)\n\n      predicate = d =>\n        exact ? d.queryHash === queryHash : deepIncludes(d.queryKey, queryKey)\n    }\n\n    return Object.values(queryCache.queries).filter(predicate)\n  }\n\n  queryCache.getQuery = queryKey =>\n    queryCache.getQueries(queryKey, { exact: true })[0]\n\n  queryCache.getQueryData = queryKey =>\n    queryCache.getQuery(queryKey)?.state.data\n\n  queryCache.removeQueries = (...args) => {\n    queryCache.getQueries(...args).forEach(query => query.clear())\n  }\n\n  queryCache.cancelQueries = (...args) => {\n    queryCache.getQueries(...args).forEach(query => query.cancel())\n  }\n\n  queryCache.invalidateQueries = async (\n    predicate,\n    { refetchActive = true, exact, throwOnError } = {}\n  ) => {\n    try {\n      return await Promise.all(\n        queryCache.getQueries(predicate, { exact }).map(query => {\n          if (refetchActive && query.instances.length) {\n            return query.fetch()\n          }\n\n          return query.invalidate()\n        })\n      )\n    } catch (err) {\n      if (throwOnError) {\n        throw err\n      }\n    }\n  }\n\n  queryCache.resetErrorBoundaries = () => {\n    queryCache.getQueries(true).forEach(query => {\n      query.state.throwInErrorBoundary = false\n    })\n  }\n\n  queryCache.buildQuery = (userQueryKey, queryFn, config = {}) => {\n    config = {\n      ...configRef.current.shared,\n      ...configRef.current.queries,\n      ...config,\n    }\n\n    let [queryHash, queryKey] = config.queryKeySerializerFn(userQueryKey)\n\n    let query = queryCache.queries[queryHash]\n\n    if (query) {\n      Object.assign(query, { queryFn, config })\n    } else {\n      query = makeQuery({\n        queryCache,\n        queryKey,\n        queryHash,\n        queryFn,\n        config,\n      })\n\n      // If the query started with data, schedule\n      // a stale timeout\n      if (!isServer && query.state.data) {\n        query.scheduleStaleTimeout()\n\n        // Simulate a query healing process\n        query.heal()\n        // Schedule for garbage collection in case\n        // nothing subscribes to this query\n        query.scheduleGarbageCollection()\n      }\n\n      if (!frozen) {\n        queryCache.queries[queryHash] = query\n\n        if (isServer) {\n          notifyGlobalListeners()\n        } else {\n          // Here, we setTimeout so as to not trigger\n          // any setState's in parent components in the\n          // middle of the render phase.\n          setTimeout(() => {\n            notifyGlobalListeners()\n          })\n        }\n      }\n    }\n\n    query.fallbackInstance = {\n      config: {\n        onSuccess: query.config.onSuccess,\n        onError: query.config.onError,\n        onSettled: query.config.onSettled,\n      },\n    }\n\n    return query\n  }\n\n  queryCache.prefetchQuery = async (...args) => {\n    let [\n      queryKey,\n      queryFn,\n      config,\n      { force, throwOnError } = {},\n    ] = getQueryArgs(args)\n\n    try {\n      const query = queryCache.buildQuery(queryKey, queryFn, config)\n      if (force || query.state.isStale) {\n        await query.fetch()\n      }\n      return query.state.data\n    } catch (err) {\n      if (throwOnError) {\n        throw err\n      }\n    }\n  }\n\n  queryCache.setQueryData = (queryKey, updater, config = {}) => {\n    let query = queryCache.getQuery(queryKey)\n\n    if (!query) {\n      query = queryCache.buildQuery(queryKey, () => new Promise(noop), config)\n    }\n\n    query.setData(updater)\n  }\n\n  function makeQuery({ queryCache, queryKey, queryHash, queryFn, config }) {\n    const initialData =\n      typeof config.initialData === 'function'\n        ? config.initialData()\n        : config.initialData\n\n    const hasInitialData = typeof initialData !== 'undefined'\n\n    const isStale = !config.enabled || !hasInitialData\n\n    const initialStatus = hasInitialData\n      ? statusSuccess\n      : config.enabled\n      ? statusLoading\n      : statusIdle\n\n    let query = {\n      queryKey,\n      queryHash,\n      queryFn,\n      config,\n      instances: [],\n      state: queryReducer(undefined, {\n        type: actionInit,\n        initialStatus,\n        initialData,\n        hasInitialData,\n        isStale,\n      }),\n    }\n\n    query.dispatch = action => {\n      query.state = queryReducer(query.state, action)\n      query.instances.forEach(d => d.onStateUpdate(query.state))\n      notifyGlobalListeners()\n    }\n\n    query.scheduleStaleTimeout = () => {\n      if (isServer) return\n      clearTimeout(query.staleTimeout)\n\n      if (query.config.staleTime === Infinity) {\n        return\n      }\n\n      query.staleTimeout = setTimeout(() => {\n        if (queryCache.getQuery(query.queryKey)) {\n          query.invalidate()\n        }\n      }, query.config.staleTime)\n    }\n\n    query.invalidate = () => {\n      clearTimeout(query.staleTimeout)\n      query.dispatch({ type: actionMarkStale })\n    }\n\n    query.scheduleGarbageCollection = () => {\n      if (query.config.cacheTime === Infinity) {\n        return\n      }\n      query.dispatch({ type: actionMarkGC })\n      query.cacheTimeout = setTimeout(\n        () => {\n          queryCache.removeQueries(\n            d =>\n              d.state.markedForGarbageCollection &&\n              d.queryHash === query.queryHash\n          )\n        },\n        typeof query.state.data === 'undefined' &&\n          query.state.status !== 'error'\n          ? 0\n          : query.config.cacheTime\n      )\n    }\n\n    query.heal = () => {\n      // Stop the query from being garbage collected\n      clearTimeout(query.cacheTimeout)\n\n      // Mark the query as not cancelled\n      query.cancelled = null\n    }\n\n    query.cancel = () => {\n      query.cancelled = cancelledError\n\n      if (query.cancelPromises) {\n        query.cancelPromises()\n      }\n\n      delete query.promise\n    }\n\n    query.clearIntervals = () => {\n      query.instances.forEach(instance => {\n        instance.clearInterval()\n      })\n    }\n\n    query.setState = updater =>\n      query.dispatch({ type: actionSetState, updater })\n\n    query.setData = updater => {\n      // Set data and mark it as cached\n      query.dispatch({ type: actionSuccess, updater })\n\n      // Schedule a fresh invalidation!\n      query.scheduleStaleTimeout()\n    }\n\n    query.clear = () => {\n      clearTimeout(query.staleTimeout)\n      clearTimeout(query.cacheTimeout)\n      clearTimeout(query.retryTimeout)\n      query.clearIntervals()\n      query.cancel()\n      query.dispatch = noop\n      delete queryCache.queries[query.queryHash]\n    }\n\n    query.subscribe = (onStateUpdate = noop) => {\n      const instance = {\n        id: uid(),\n        onStateUpdate,\n      }\n\n      query.instances.push(instance)\n\n      query.heal()\n\n      instance.clearInterval = () => {\n        clearInterval(instance.refetchIntervalId)\n        delete instance.refetchIntervalId\n      }\n\n      instance.updateConfig = config => {\n        const oldConfig = instance.config\n\n        // Update the config\n        instance.config = config\n\n        if (!isServer) {\n          if (oldConfig?.refetchInterval === config.refetchInterval) {\n            return\n          }\n\n          query.clearIntervals()\n\n          const minInterval = Math.min(\n            ...query.instances.map(d => d.config.refetchInterval || Infinity)\n          )\n\n          if (\n            !instance.refetchIntervalId &&\n            minInterval > 0 &&\n            minInterval < Infinity\n          ) {\n            instance.refetchIntervalId = setInterval(() => {\n              if (\n                isDocumentVisible() ||\n                query.instances.some(\n                  instance => instance.config.refetchIntervalInBackground\n                )\n              ) {\n                query.fetch()\n              }\n            }, minInterval)\n          }\n        }\n      }\n\n      instance.run = async () => {\n        try {\n          // Perform the refetch for this query if necessary\n          if (\n            query.config.enabled && // Don't auto refetch if disabled\n            !query.wasSuspended && // Don't double refetch for suspense\n            query.state.isStale && // Only refetch if stale\n            (query.config.refetchOnMount || query.instances.length === 1)\n          ) {\n            await query.fetch()\n          }\n\n          query.wasSuspended = false\n        } catch (error) {\n          Console.error(error)\n        }\n      }\n\n      instance.unsubscribe = () => {\n        query.instances = query.instances.filter(d => d.id !== instance.id)\n\n        if (!query.instances.length) {\n          query.clearIntervals()\n          query.cancel()\n\n          if (!isServer) {\n            // Schedule garbage collection\n            query.scheduleGarbageCollection()\n          }\n        }\n      }\n\n      return instance\n    }\n\n    // Set up the core fetcher function\n    const tryFetchData = async (queryFn, ...args) => {\n      try {\n        // Perform the query\n        const promise = queryFn(...query.config.queryFnParamsFilter(args))\n\n        query.cancelPromises = () => promise.cancel?.()\n\n        const data = await promise\n        delete query.shouldContinueRetryOnFocus\n\n        delete query.cancelPromises\n        if (query.cancelled) throw query.cancelled\n\n        return data\n      } catch (error) {\n        delete query.cancelPromises\n        if (query.cancelled) throw query.cancelled\n\n        // If we fail, increase the failureCount\n        query.dispatch({ type: actionFailed })\n\n        // Do we need to retry the request?\n        if (\n          query.config.retry === true ||\n          query.state.failureCount <= query.config.retry ||\n          (typeof query.config.retry === 'function' &&\n            query.config.retry(query.state.failureCount, error))\n        ) {\n          // Only retry if the document is visible\n          if (!isDocumentVisible()) {\n            // set this flag to continue retries on focus\n            query.shouldContinueRetryOnFocus = true\n            return new Promise(noop)\n          }\n\n          delete query.shouldContinueRetryOnFocus\n\n          // Determine the retryDelay\n          const delay = functionalUpdate(\n            query.config.retryDelay,\n            query.state.failureCount\n          )\n\n          // Return a new promise with the retry\n          return await new Promise((resolve, reject) => {\n            // Keep track of the retry timeout\n            query.retryTimeout = setTimeout(async () => {\n              if (query.cancelled) return reject(query.cancelled)\n\n              try {\n                const data = await tryFetchData(queryFn, ...args)\n                if (query.cancelled) return reject(query.cancelled)\n                resolve(data)\n              } catch (error) {\n                if (query.cancelled) return reject(query.cancelled)\n                reject(error)\n              }\n            }, delay)\n          })\n        }\n\n        throw error\n      }\n    }\n\n    query.fetch = async ({ __queryFn = query.queryFn } = {}) => {\n      // Create a new promise for the query cache if necessary\n      if (!query.promise) {\n        query.promise = (async () => {\n          // If there are any retries pending for this query, kill them\n          query.cancelled = null\n\n          const callbackInstances = [...query.instances]\n\n          if (query.wasSuspended) {\n            callbackInstances.unshift(query.fallbackInstance)\n          }\n\n          try {\n            // Set up the query refreshing state\n            query.dispatch({ type: actionFetch })\n\n            // Try to get the data\n            let data = await tryFetchData(__queryFn, ...query.queryKey)\n\n            query.setData(old =>\n              query.config.isDataEqual(old, data) ? old : data\n            )\n\n            callbackInstances.forEach(\n              instance =>\n                instance.config.onSuccess &&\n                instance.config.onSuccess(query.state.data)\n            )\n\n            callbackInstances.forEach(\n              instance =>\n                instance.config.onSettled &&\n                instance.config.onSettled(query.state.data, null)\n            )\n\n            delete query.promise\n\n            return data\n          } catch (error) {\n            query.dispatch({\n              type: actionError,\n              cancelled: error === query.cancelled,\n              error,\n            })\n\n            delete query.promise\n\n            if (error !== query.cancelled) {\n              callbackInstances.forEach(\n                instance =>\n                  instance.config.onError && instance.config.onError(error)\n              )\n\n              callbackInstances.forEach(\n                instance =>\n                  instance.config.onSettled &&\n                  instance.config.onSettled(undefined, error)\n              )\n\n              throw error\n            }\n          }\n        })()\n      }\n\n      return query.promise\n    }\n\n    return query\n  }\n\n  return queryCache\n}\n\nexport function queryReducer(state, action) {\n  const newState = switchActions(state, action)\n\n  Object.assign(newState, {\n    isLoading: newState.status === statusLoading,\n    isSuccess: newState.status === statusSuccess,\n    isError: newState.status === statusError,\n    isIdle: newState.status === statusIdle,\n  })\n\n  return newState\n}\n\nfunction switchActions(state, action) {\n  switch (action.type) {\n    case actionInit:\n      return {\n        status: action.initialStatus,\n        error: null,\n        isFetching: action.initialStatus === 'loading',\n        canFetchMore: false,\n        failureCount: 0,\n        isStale: action.isStale,\n        markedForGarbageCollection: false,\n        data: action.initialData,\n        updatedAt: action.hasInitialData ? Date.now() : 0,\n      }\n    case actionFailed:\n      return {\n        ...state,\n        failureCount: state.failureCount + 1,\n      }\n    case actionMarkStale:\n      return {\n        ...state,\n        isStale: true,\n      }\n    case actionMarkGC: {\n      return {\n        ...state,\n        markedForGarbageCollection: true,\n      }\n    }\n    case actionFetch:\n      return {\n        ...state,\n        status:\n          typeof state.data !== 'undefined' ? statusSuccess : statusLoading,\n        isFetching: true,\n        failureCount: 0,\n      }\n    case actionSuccess:\n      return {\n        ...state,\n        status: statusSuccess,\n        data: functionalUpdate(action.updater, state.data),\n        error: null,\n        isStale: false,\n        isFetching: false,\n        canFetchMore: action.canFetchMore,\n        updatedAt: Date.now(),\n        failureCount: 0,\n      }\n    case actionError:\n      return {\n        ...state,\n        isFetching: false,\n        isStale: true,\n        ...(!action.cancelled && {\n          status: statusError,\n          error: action.error,\n          throwInErrorBoundary: true,\n        }),\n      }\n    case actionSetState:\n      return functionalUpdate(action.updater, state)\n    default:\n      throw new Error()\n  }\n}\n","import { isOnline, isDocumentVisible, Console, isServer } from './utils'\nimport { queryCaches } from './queryCache'\n\nconst visibilityChangeEvent = 'visibilitychange'\nconst focusEvent = 'focus'\n\nconst onWindowFocus = () => {\n  if (isDocumentVisible() && isOnline()) {\n    queryCaches.forEach(queryCache =>\n      queryCache\n        .invalidateQueries(query => {\n          if (!query.instances.length) {\n            return false\n          }\n\n          if (!query.instances.some(instance => instance.config.enabled)) {\n            return false\n          }\n\n          if (!query.state.isStale) {\n            return false\n          }\n\n          if (query.shouldContinueRetryOnFocus) {\n            // delete promise, so refetching will create new one\n            delete query.promise\n          }\n\n          return query.config.refetchOnWindowFocus\n        })\n        .catch(Console.error)\n    )\n  }\n}\n\nlet removePreviousHandler\n\nexport function setFocusHandler(callback) {\n  // Unsub the old watcher\n  if (removePreviousHandler) {\n    removePreviousHandler()\n  }\n  // Sub the new watcher\n  removePreviousHandler = callback(onWindowFocus)\n}\n\nsetFocusHandler(handleFocus => {\n  // Listen to visibillitychange and focus\n  if (!isServer && window?.addEventListener) {\n    window.addEventListener(visibilityChangeEvent, handleFocus, false)\n    window.addEventListener(focusEvent, handleFocus, false)\n\n    return () => {\n      // Be sure to unsubscribe if a new handler is set\n      window.removeEventListener(visibilityChangeEvent, handleFocus)\n      window.removeEventListener(focusEvent, handleFocus)\n    }\n  }\n})\n","import React from 'react'\n\n//\n\nimport { useConfigContext } from './config'\nimport {\n  statusIdle,\n  statusLoading,\n  statusSuccess,\n  statusError,\n  useGetLatest,\n  Console,\n  uid,\n  useMountedCallback,\n  noop,\n} from './utils'\n\nconst getDefaultState = () => ({\n  status: statusIdle,\n  data: undefined,\n  error: null,\n})\n\nconst actionReset = {}\nconst actionLoading = {}\nconst actionResolve = {}\nconst actionReject = {}\n\nfunction mutationReducer(state, action) {\n  if (action.type === actionReset) {\n    return getDefaultState()\n  }\n  if (action.type === actionLoading) {\n    return {\n      status: statusLoading,\n    }\n  }\n  if (action.type === actionResolve) {\n    return {\n      status: statusSuccess,\n      data: action.data,\n    }\n  }\n  if (action.type === actionReject) {\n    return {\n      status: statusError,\n      error: action.error,\n    }\n  }\n  throw new Error()\n}\n\nexport function useMutation(mutationFn, config = {}) {\n  const [state, unsafeDispatch] = React.useReducer(\n    mutationReducer,\n    null,\n    getDefaultState\n  )\n\n  const dispatch = useMountedCallback(unsafeDispatch)\n\n  const getMutationFn = useGetLatest(mutationFn)\n\n  const getConfig = useGetLatest({\n    ...useConfigContext().shared,\n    ...useConfigContext().mutations,\n    ...config,\n  })\n\n  const latestMutationRef = React.useRef()\n\n  const mutate = React.useCallback(\n    async (\n      variables,\n      { onSuccess = noop, onError = noop, onSettled = noop, throwOnError } = {}\n    ) => {\n      const config = getConfig()\n\n      const mutationId = uid()\n      latestMutationRef.current = mutationId\n\n      const isLatest = () => latestMutationRef.current === mutationId\n\n      dispatch({ type: actionLoading })\n\n      let snapshotValue\n\n      try {\n        snapshotValue = await config.onMutate(variables)\n\n        let data\n\n        if (isLatest()) {\n          data = await getMutationFn()(variables)\n        }\n\n        if (isLatest()) {\n          dispatch({ type: actionResolve, data })\n        }\n\n        if (isLatest()) {\n          await config.onSuccess(data, variables)\n        }\n\n        if (isLatest()) {\n          await onSuccess(data, variables)\n        }\n\n        if (isLatest()) {\n          await config.onSettled(data, null, variables)\n        }\n\n        if (isLatest()) {\n          await onSettled(data, null, variables)\n        }\n\n        return data\n      } catch (error) {\n        if (isLatest()) {\n          Console.error(error)\n          await config.onError(error, variables, snapshotValue)\n        }\n\n        if (isLatest()) {\n          await onError(error, variables, snapshotValue)\n        }\n\n        if (isLatest()) {\n          await config.onSettled(undefined, error, variables, snapshotValue)\n        }\n\n        if (isLatest()) {\n          await onSettled(undefined, error, variables, snapshotValue)\n        }\n\n        if (isLatest()) {\n          dispatch({ type: actionReject, error })\n\n          if (throwOnError ?? config.throwOnError) {\n            throw error\n          }\n        }\n      }\n    },\n    [dispatch, getConfig, getMutationFn]\n  )\n\n  const reset = React.useCallback(() => dispatch({ type: actionReset }), [\n    dispatch,\n  ])\n\n  React.useEffect(() => {\n    const { suspense, useErrorBoundary } = getConfig()\n\n    if ((useErrorBoundary ?? suspense) && state.error) {\n      throw state.error\n    }\n  }, [getConfig, state.error])\n\n  return [\n    mutate,\n    {\n      ...state,\n      reset,\n      isIdle: state.status === statusIdle,\n      isLoading: state.status === statusLoading,\n      isSuccess: state.status === statusSuccess,\n      isError: state.status === statusError,\n    },\n  ]\n}\n","import React from 'react'\n\n//\n\nimport { useQueryCache } from './queryCache'\nimport { useConfigContext } from './config'\nimport { useMountedCallback, Console } from './utils'\n\nexport function useBaseQuery(queryKey, queryFn, config = {}) {\n  // Make a rerender function\n  const rerender = useMountedCallback(React.useState()[1])\n\n  // Build the final config\n  const configContext = useConfigContext()\n\n  config = {\n    ...configContext.shared,\n    ...configContext.queries,\n    ...config,\n  }\n\n  // Get the query cache\n  const queryCache = useQueryCache()\n\n  // Build the query for use\n  const query = queryCache.buildQuery(queryKey, queryFn, config)\n\n  // Create a query instance ref\n  const instanceRef = React.useRef()\n\n  // Subscribe to the query when the subscribe function changes\n  React.useEffect(() => {\n    instanceRef.current = query.subscribe(() => rerender({}))\n\n    // Unsubscribe when things change\n    return instanceRef.current.unsubscribe\n  }, [query, rerender])\n\n  // Always update the config\n  React.useEffect(() => {\n    instanceRef.current.updateConfig(config)\n  })\n\n  // Run the instance when the query or enabled change\n  React.useEffect(() => {\n    if (config.enabled && query) {\n      // Just for change detection\n    }\n    instanceRef.current.run()\n  }, [config.enabled, query])\n\n  const refetch = React.useCallback(async () => {\n    try {\n      await query.fetch()\n    } catch (error) {\n      Console.error(error)\n    }\n  }, [query])\n\n  return {\n    query,\n    refetch,\n    ...query.state,\n  }\n}\n","import React from 'react'\n\n//\n\nimport { useBaseQuery } from './useBaseQuery'\nimport { getQueryArgs, useGetLatest, handleSuspense } from './utils'\n\nexport function useInfiniteQuery(...args) {\n  const queryInfoRef = React.useRef()\n  let [queryKey, queryFn, config = {}] = getQueryArgs(args)\n\n  const { getFetchMore } = config\n  const getGetFetchMore = useGetLatest(getFetchMore)\n\n  // The default queryFn will query all pages and map them together\n  const originalQueryFn = queryFn\n\n  queryFn = async () => {\n    const data = []\n    const pageVariables = [...queryInfoRef.current.query.pageVariables]\n    const rebuiltPageVariables = []\n\n    do {\n      const args = pageVariables.shift()\n\n      if (!data.length) {\n        // the first page query doesn't need to be rebuilt\n        data.push(await originalQueryFn(...args))\n        rebuiltPageVariables.push(args)\n      } else {\n        // get an up-to-date cursor based on the previous data set\n        const nextCursor = getGetFetchMore()(data[data.length - 1], data)\n\n        // break early if there's no next cursor\n        // otherwise we'll start from the beginning\n        // which will cause unwanted duplication\n        if (!nextCursor) {\n          break\n        }\n\n        const pageArgs = [\n          // remove the last argument (the previously saved cursor)\n          ...args.slice(0, -1),\n          nextCursor,\n        ]\n\n        data.push(await originalQueryFn(...pageArgs))\n        rebuiltPageVariables.push(pageArgs)\n      }\n    } while (pageVariables.length)\n\n    queryInfoRef.current.query.canFetchMore = getGetFetchMore()(\n      data[data.length - 1],\n      data\n    )\n    queryInfoRef.current.query.pageVariables = rebuiltPageVariables\n\n    return data\n  }\n\n  const queryInfo = useBaseQuery(queryKey, queryFn, config)\n\n  if (\n    typeof queryInfo.query.canFetchMore === 'undefined' &&\n    typeof queryInfo.data !== 'undefined'\n  ) {\n    queryInfo.query.canFetchMore = getGetFetchMore()(\n      queryInfo.data[queryInfo.data.length - 1],\n      queryInfo.data\n    )\n  }\n\n  queryInfoRef.current = queryInfo\n\n  let {\n    data = [],\n    query: { canFetchMore },\n  } = queryInfo\n\n  // Here we seed the pageVariabes for the query\n  if (!queryInfo.query.pageVariables) {\n    queryInfo.query.pageVariables = [[...queryInfo.query.queryKey]]\n  }\n\n  const fetchMore = React.useCallback(\n    (\n      fetchMoreInfo = queryInfoRef.current.query.canFetchMore,\n      { previous = false } = {}\n    ) =>\n      queryInfoRef.current.query.canFetchMore\n        ? queryInfoRef.current.query.fetch({\n            __queryFn: async (...args) => {\n              try {\n                queryInfoRef.current.query.setState(old => ({\n                  ...old,\n                  isFetchingMore: previous ? 'previous' : 'next',\n                }))\n\n                const newArgs = previous\n                  ? [fetchMoreInfo, ...args]\n                  : [...args, fetchMoreInfo]\n                queryInfoRef.current.query.pageVariables[\n                  previous ? 'unshift' : 'push'\n                ](newArgs)\n\n                const newData = await originalQueryFn(...newArgs)\n\n                const data = previous\n                  ? [newData, ...queryInfoRef.current.data]\n                  : [...queryInfoRef.current.data, newData]\n\n                queryInfoRef.current.query.canFetchMore = getGetFetchMore()(\n                  newData,\n                  data\n                )\n\n                return data\n              } finally {\n                queryInfoRef.current.query.setState(old => ({\n                  ...old,\n                  isFetchingMore: false,\n                }))\n              }\n            },\n          })\n        : void 0,\n    [getGetFetchMore, originalQueryFn]\n  )\n\n  handleSuspense(queryInfo)\n\n  return {\n    ...queryInfo,\n    data,\n    canFetchMore,\n    fetchMore,\n  }\n}\n","import React from 'react'\n\nimport { useMountedCallback } from './utils'\nimport { useQueryCache } from './queryCache'\n\nexport function useIsFetching() {\n  const queryCache = useQueryCache()\n  const [state, unsafeRerender] = React.useReducer(d => d + 1, 1)\n  const rerender = useMountedCallback(unsafeRerender)\n\n  React.useEffect(() => queryCache.subscribe(rerender), [queryCache, rerender])\n\n  return React.useMemo(() => state && queryCache.isFetching, [\n    queryCache.isFetching,\n    state,\n  ])\n}\n","import React from 'react'\n\n//\n\nimport { useBaseQuery } from './useBaseQuery'\nimport { getQueryArgs, handleSuspense } from './utils'\n\nexport function usePaginatedQuery(...args) {\n  let [queryKey, queryFn, config = {}] = getQueryArgs(args)\n\n  const lastDataRef = React.useRef()\n\n  // If latestData is set, don't use initialData\n  if (typeof lastDataRef.current !== 'undefined') {\n    delete config.initialData\n  }\n\n  const queryInfo = useBaseQuery(queryKey, queryFn, config)\n\n  if (!queryInfo.query.config.enabled) {\n    lastDataRef.current = undefined\n  }\n\n  let { data: latestData, status } = queryInfo\n\n  React.useEffect(() => {\n    if (status === 'success' && typeof latestData !== 'undefined') {\n      lastDataRef.current = latestData\n    }\n  }, [latestData, status])\n\n  let resolvedData = latestData\n\n  if (typeof resolvedData === 'undefined') {\n    resolvedData = lastDataRef.current\n  }\n\n  if (typeof resolvedData !== 'undefined') {\n    const overrides = {\n      status: 'success',\n      isError: false,\n      isLoading: false,\n      isSuccess: true,\n    }\n\n    Object.assign(queryInfo.query.state, overrides)\n    Object.assign(queryInfo, overrides)\n  }\n\n  const paginatedQueryInfo = {\n    ...queryInfo,\n    resolvedData,\n    latestData,\n  }\n\n  handleSuspense(paginatedQueryInfo)\n\n  return paginatedQueryInfo\n}\n","import { useBaseQuery } from './useBaseQuery'\nimport { getQueryArgs, handleSuspense } from './utils'\n\nexport function useQuery(...args) {\n  const query = useBaseQuery(...getQueryArgs(args))\n\n  handleSuspense(query)\n\n  return query\n}\n"],"names":["_uid","uid","cancelledError","isServer","window","noop","Console","console","error","warn","log","useGetLatest","obj","ref","React","useRef","current","useCallback","functionalUpdate","updater","old","stableStringifyReplacer","_","value","isObject","Object","assign","keys","sort","map","key","stableStringify","JSON","stringify","a","Array","isArray","deepIncludes","b","some","isDocumentVisible","document","undefined","visibilityState","getQueryArgs","args","hasOwnProperty","queryKey","queryFn","config","slice","Error","rest","useMountedCallback","callback","mounted","handleSuspense","queryInfo","query","suspense","useErrorBoundary","state","status","throwInErrorBoundary","wasSuspended","fetch","configContext","createContext","DEFAULTS","shared","queryKeySerializerFn","invalidQueryKey","d","queryHash","parse","queries","enabled","retry","retryDelay","attemptIndex","Math","min","staleTime","cacheTime","refetchOnWindowFocus","refetchInterval","queryFnParamsFilter","refetchOnMount","isDataEqual","deepEqual","length","i","valueOf","prototype","call","onError","onSuccess","onSettled","mutations","throwOnError","onMutate","defaultConfigRef","useConfigContext","useContext","then","direct","Promise","resolve","body","recover","result","e","f","arguments","apply","this","reject","queryCache","makeQueryCache","queryCacheContext","queryCaches","useQueryCache","frozen","defaultConfig","globalListeners","configRef","isFetching","notifyGlobalListeners","values","reduce","acc","forEach","subscribe","cb","push","splice","indexOf","clear","notify","getQueries","predicate","exact","filter","getQuery","getQueryData","_queryCache$getQuery","data","removeQueries","cancelQueries","cancel","invalidateQueries","refetchActive","all","instances","invalidate","err","resetErrorBoundaries","buildQuery","userQueryKey","initialData","hasInitialData","isStale","initialStatus","queryReducer","type","dispatch","action","onStateUpdate","scheduleStaleTimeout","clearTimeout","staleTimeout","Infinity","setTimeout","scheduleGarbageCollection","cacheTimeout","markedForGarbageCollection","heal","cancelled","cancelPromises","promise","clearIntervals","instance","clearInterval","setState","setData","retryTimeout","id","refetchIntervalId","updateConfig","oldConfig","minInterval","setInterval","refetchIntervalInBackground","run","unsubscribe","tryFetchData","shouldContinueRetryOnFocus","failureCount","delay","__queryFn","_async","callbackInstances","unshift","fallbackInstance","makeQuery","prefetchQuery","force","setQueryData","newState","canFetchMore","updatedAt","Date","now","switchActions","isLoading","isSuccess","isError","isIdle","removePreviousHandler","onWindowFocus","navigator","onLine","catch","setFocusHandler","_await","handleFocus","_window","addEventListener","removeEventListener","getDefaultState","_empty","actionReset","_awaitIgnored","actionLoading","_invoke","actionResolve","actionReject","mutationReducer","useBaseQuery","rerender","useState","instanceRef","useEffect","refetch","pact","s","o","_settle","bind","v","observer","_Pact","onFulfilled","onRejected","_this","thenable","test","awaitBody","_isSettledPact","shouldContinue","_resumeAfterBody","_resumeAfterTest","thrown","finalizer","children","resolvedQueryCache","useMemo","Provider","configContextValue","newConfig","contextShared","contextQueries","contextMutations","c","queryInfoRef","getFetchMore","getGetFetchMore","originalQueryFn","pageVariables","rebuiltPageVariables","shift","nextCursor","pageArgs","fetchMore","fetchMoreInfo","previous","isFetchingMore","newArgs","newData","useReducer","mutationFn","getMutationFn","getConfig","latestMutationRef","mutate","variables","mutationId","snapshotValue","isLatest","reset","lastDataRef","latestData","resolvedData","overrides","paginatedQueryInfo"],"mappings":"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"}