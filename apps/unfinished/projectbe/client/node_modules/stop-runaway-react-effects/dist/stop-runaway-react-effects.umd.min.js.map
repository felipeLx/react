{"version":3,"file":"stop-runaway-react-effects.umd.min.js","sources":["../src/index.js"],"sourcesContent":["import React from 'react'\n\n// I'm not sure these are the right numbers and changes to these numbers will\n// not be considered breaking. We're just trying to approximate what a usual\n// combination would be to determine whether the effect is runaway.\nconst DEFAULT_CALL_COUNT = 60\nconst DEFAULT_TIME_LIMIT = 1000\n\n// this file is basically gone in production...\n// but people can still call the functions safely either way.\nconst noop = () => function restore() {}\nconst last = array => array[array.length - 1]\n\nconst hijackEffectHook =\n  process.env.NODE_ENV === 'production'\n    ? noop\n    : function hijackEffectHook(\n        hookName,\n        {callCount = DEFAULT_CALL_COUNT, timeLimit = DEFAULT_TIME_LIMIT} = {},\n      ) {\n        const originalHook = React[hookName]\n\n        React[hookName] = getHijackedEffectHook({\n          hookName,\n          callCount,\n          timeLimit,\n        })\n\n        return function restore() {\n          React[hookName] = originalHook\n        }\n      }\n\nfunction getHijackedEffectHook({hookName, callCount, timeLimit}) {\n  const originalHook = React[hookName]\n  return function useHijackedEffect(...args) {\n    const [hookCallback, deps] = args\n    const ref = React.useRef([])\n    const warnedRef = React.useRef(false)\n\n    return originalHook.call(\n      React,\n      () => {\n        const calls = ref.current\n        const oldestCall = last(calls)\n        const now = Date.now()\n        calls.push({time: now, args})\n        if (\n          !warnedRef.current &&\n          calls.length >= callCount &&\n          oldestCall.time > now - timeLimit\n        ) {\n          const allRecentCallDependencies = calls.map(c => c.args[1])\n          const messages = [\n            `The following effect callback was invoked ${callCount} times in ${timeLimit}ms`,\n            '\\n',\n            hookCallback.toString(),\n          ]\n          if (allRecentCallDependencies.some(Boolean)) {\n            messages.push(\n              '\\n',\n              `Here are the dependencies this effect was called with the last ${callCount} times:`,\n              allRecentCallDependencies,\n            )\n            messages.push(\n              '\\n',\n              `Here are the dependency changes between each call:`,\n              allRecentCallDependencies.map((callDeps, callIndex) => {\n                if (callIndex === 0) {\n                  return callDeps\n                }\n                return callDeps.map((dep, depIndex) => {\n                  const prevDep =\n                    allRecentCallDependencies[callIndex - 1][depIndex]\n                  return Object.is(dep, prevDep) ? 'UNCHANGED' : dep\n                })\n              }),\n            )\n            messages.push(\n              '\\n',\n              `Try to find where those changing dependencies are initialized. You probably need to memoize them using React.useMemo or React.useCallback`,\n            )\n          } else {\n            messages.push(\n              '\\n',\n              `This effect is not called with a dependencies argument and probably should. Start by adding \\`[]\\` as a second argument to the ${hookName} call, then add any other dependencies as elements to that array. You may also be interested in installing ESLint with https://npm.im/eslint-plugin-react-hooks`,\n            )\n          }\n          console.warn(...messages)\n          warnedRef.current = true\n\n          throw new Error(\n            `Uh oh... Looks like we've got a runaway ${hookName}. Check the console for more info. Make sure the ${hookName} is being passed the right dependencies. (By the way, this error message is from https://npm.im/stop-runaway-react-effects, not React)`,\n          )\n        }\n\n        // remove old records\n        ref.current = calls\n          // only store up to the callCount\n          .slice(0, callCount)\n          // only store effects called within the timeLimit\n          .filter(r => r.time > now - timeLimit)\n\n        // call the original callback\n        return hookCallback()\n      },\n      deps,\n    )\n  }\n}\n\nconst hijackEffects =\n  process.env.NODE_ENV === 'production'\n    ? noop\n    : function hijackEffects(options) {\n        const restoreUseEffect = hijackEffectHook('useEffect', options)\n        const restoreUseLayoutEffect = hijackEffectHook(\n          'useLayoutEffect',\n          options,\n        )\n        return function restore() {\n          restoreUseEffect()\n          restoreUseLayoutEffect()\n        }\n      }\n\nexport {hijackEffects, hijackEffectHook}\n"],"names":["noop","hijackEffectHook","hijackEffects"],"mappings":"2TAUA,IAAMA,EAAO,kBAAM,cAGbC,EAEAD,EAgGAE,EAEAF"}