import React from 'react';

// not be considered breaking. We're just trying to approximate what a usual
// combination would be to determine whether the effect is runaway.

var DEFAULT_CALL_COUNT = 60;
var DEFAULT_TIME_LIMIT = 1000; // this file is basically gone in production...
// but people can still call the functions safely either way.

var noop = function () {
  return function () {};
};

var last = function (array) {
  return array[array.length - 1];
};

var hijackEffectHook = process.env.NODE_ENV === 'production' ? noop : function (hookName, _temp) {
  var _ref = _temp === void 0 ? {} : _temp,
      _ref$callCount = _ref.callCount,
      callCount = _ref$callCount === void 0 ? DEFAULT_CALL_COUNT : _ref$callCount,
      _ref$timeLimit = _ref.timeLimit,
      timeLimit = _ref$timeLimit === void 0 ? DEFAULT_TIME_LIMIT : _ref$timeLimit;

  var originalHook = React[hookName];
  React[hookName] = getHijackedEffectHook({
    hookName: hookName,
    callCount: callCount,
    timeLimit: timeLimit
  });
  return function () {
    React[hookName] = originalHook;
  };
};

function getHijackedEffectHook(_ref2) {
  var hookName = _ref2.hookName,
      callCount = _ref2.callCount,
      timeLimit = _ref2.timeLimit;
  var originalHook = React[hookName];
  return function () {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var hookCallback = args[0],
        deps = args[1];
    var ref = React.useRef([]);
    var warnedRef = React.useRef(false);
    return originalHook.call(React, function () {
      var calls = ref.current;
      var oldestCall = last(calls);
      var now = Date.now();
      calls.push({
        time: now,
        args: args
      });

      if (!warnedRef.current && calls.length >= callCount && oldestCall.time > now - timeLimit) {
        var _console;

        var allRecentCallDependencies = calls.map(function (c) {
          return c.args[1];
        });
        var messages = ["The following effect callback was invoked " + callCount + " times in " + timeLimit + "ms", '\n', hookCallback.toString()];

        if (allRecentCallDependencies.some(Boolean)) {
          messages.push('\n', "Here are the dependencies this effect was called with the last " + callCount + " times:", allRecentCallDependencies);
          messages.push('\n', "Here are the dependency changes between each call:", allRecentCallDependencies.map(function (callDeps, callIndex) {
            if (callIndex === 0) {
              return callDeps;
            }

            return callDeps.map(function (dep, depIndex) {
              var prevDep = allRecentCallDependencies[callIndex - 1][depIndex];
              return Object.is(dep, prevDep) ? 'UNCHANGED' : dep;
            });
          }));
          messages.push('\n', "Try to find where those changing dependencies are initialized. You probably need to memoize them using React.useMemo or React.useCallback");
        } else {
          messages.push('\n', "This effect is not called with a dependencies argument and probably should. Start by adding `[]` as a second argument to the " + hookName + " call, then add any other dependencies as elements to that array. You may also be interested in installing ESLint with https://npm.im/eslint-plugin-react-hooks");
        }

        (_console = console).warn.apply(_console, messages);

        warnedRef.current = true;
        throw new Error("Uh oh... Looks like we've got a runaway " + hookName + ". Check the console for more info. Make sure the " + hookName + " is being passed the right dependencies. (By the way, this error message is from https://npm.im/stop-runaway-react-effects, not React)");
      } // remove old records


      ref.current = calls // only store up to the callCount
      .slice(0, callCount) // only store effects called within the timeLimit
      .filter(function (r) {
        return r.time > now - timeLimit;
      }); // call the original callback

      return hookCallback();
    }, deps);
  };
}

var hijackEffects = process.env.NODE_ENV === 'production' ? noop : function (options) {
  var restoreUseEffect = hijackEffectHook('useEffect', options);
  var restoreUseLayoutEffect = hijackEffectHook('useLayoutEffect', options);
  return function () {
    restoreUseEffect();
    restoreUseLayoutEffect();
  };
};

export { hijackEffectHook, hijackEffects };
